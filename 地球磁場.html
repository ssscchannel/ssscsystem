<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    
    <title>æ™Ÿè‡ªç„¶è¼”åŠ©ç³»çµ±ã€€åœ°ç£èˆ‡ç£åŠ›ç·šæ¨¡æ“¬ V3</title>
    
    <style>
        /* =========================================
           1. å…¬ç‰ˆæ ¸å¿ƒæ¨£å¼
           ========================================= */
        html, body {
            margin: 0; padding: 0; width: 100%;
            height: 100dvh;
            overflow: hidden;
            display: flex; flex-direction: column; align-items: center;
            
            background-color: #000;
            background-image: 
                linear-gradient(rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0.5)), 
                url('page.jpg'); 
            background-size: cover; background-position: center;
            
            font-family: 'Microsoft JhengHei', 'Segoe UI', sans-serif;
            user-select: none; -webkit-user-select: none;
        }

        .header-container {
            flex-shrink: 0;
            width: 97%; max-width: 800px;
            box-sizing: border-box;
            display: flex; justify-content: space-between; align-items: center;
            padding: 8px 15px;
            margin-top: 5px; margin-bottom: 5px;
            
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(5px);
            border-radius: 12px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.15);
            z-index: 1000;
        }
        .header-container h1 {
            margin: 0; font-size: 1.1rem; color: #333;
            font-weight: 700; display: flex; align-items: center; gap: 10px;
            white-space: nowrap;
        }
        .title-logo { height: 36px; width: auto; border-radius: 4px; }

        .nav-buttons { display: flex; gap: 8px; align-items: center; }
        .line-btn {
            text-decoration: none; display: inline-flex; align-items: center; justify-content: center;
            padding: 6px 12px; background: #06c755; color: white;
            font-size: 0.9rem; font-weight: bold; border-radius: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2); transition: transform 0.1s;
        }
        .line-btn:active { transform: scale(0.95); }

        /* =========================================
           2. å°ˆæ¡ˆç‰¹å®šæ¨£å¼
           ========================================= */

        #simulation-area {
            flex-grow: 1; 
            width: 98%; 
            max-width: 900px;
            margin-bottom: 0; 
            display: flex; flex-direction: column; position: relative;
        }

        .simulation-container {
            flex-grow: 1;
            width: 100%;
            position: relative;
            background: rgba(20, 30, 40, 0.7);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 16px;
            box-shadow: 0 0 40px rgba(0, 0, 0, 0.4);
            overflow: hidden;
            display: flex; justify-content: center; align-items: center;
        }

        canvas {
            width: 100%; height: 100%;
            cursor: grab;
            touch-action: none;
            position: absolute; top: 0; left: 0;
        }
        canvas:active { cursor: grabbing; }

        .internal-instruction {
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.9); font-size: 1.1rem; font-weight: bold;
            pointer-events: none; text-shadow: 0 2px 8px rgba(0,0,0,0.8);
            letter-spacing: 1px;
            display: block; 
            background: rgba(0,0,0,0.3);
            padding: 5px 15px;
            border-radius: 20px;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .controls {
            position: absolute; bottom: 25px; left: 50%; transform: translateX(-50%);
            width: auto; background: none; border: none; box-shadow: none; backdrop-filter: none;
            display: flex; justify-content: center; z-index: 20;
        }

        .toggle-btn {
            background: rgba(0, 0, 0, 0.6); 
            border: 1px solid #409cff;
            color: #409cff;
            padding: 10px 30px; 
            border-radius: 30px;
            font-size: 1.1rem; 
            cursor: pointer; transition: all 0.2s;
            display: flex; align-items: center; gap: 8px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        }
        .toggle-btn:active { transform: scale(0.95); }
        .toggle-btn.active {
            background: #409cff; color: #000; font-weight: bold;
            box-shadow: 0 0 25px rgba(64, 156, 255, 0.8); 
        }

        @media (max-width: 600px) {
            .mobile-break { display: block; height: 0; }
            .header-container h1 { font-size: 1rem; }
        }
		
		/* =========================================
		[æ–°å¢æ¨¡çµ„] åº•éƒ¨æ–¹ä½é›·é”ç¾…ç›¤ (Radar Compass)
		========================================= */
		.radar-widget {
    		position: absolute;
			right: 20px;          /* é å³å´ç©ºç™½å€ */
			top: 10%;
			transform: translateY(-50%);
			width: 50px;
			height: 50px;
			border: 2px solid rgba(255, 255, 255, 0.2);
			border-radius: 50%;   /* æ­£åœ“å½¢ */
			box-sizing: border-box;
			pointer-events: none; /* ç¢ºä¿ä¸æœƒé˜»æ“‹è§¸æ§ */			
			/* æ·¡æ·¡çš„é›·é”èƒŒæ™¯è‰² */
			background: radial-gradient(circle, transparent 40%, rgba(255, 255, 255, 0.05) 100%);
		}
		
		/* åå­—æº–æ˜Ÿç·šæ¢ */
		.radar-widget::before, .radar-widget::after {
    		content: '';
			position: absolute;
			background-color: rgba(255, 255, 255, 0.15);
		}
		.radar-widget::before { /* å‚ç›´ç·š */
    		top: 5px; bottom: 5px; left: 50%; width: 1px;
		}
		.radar-widget::after { /* æ°´å¹³ç·š */
    		left: 5px; right: 5px; top: 50%; height: 1px;
		}
				
		/* æ–¹ä½æ–‡å­—æ¨™ç±¤å…±ç”¨è¨­å®š */
		.radar-label {
    		position: absolute;
			font-size: 10px;
			font-weight: bold;
			color: rgba(255, 255, 255, 0.5);
			line-height: 1;
		}
		/* å„æ–¹ä½å®šä½èˆ‡é¡è‰² */
		.label-n { top: 2px; left: 50%; transform: translateX(-50%); color: #ff4444; text-shadow: 0 0 5px rgba(255,0,0,0.5); } /* N ç´…è‰²ç™¼å…‰ */
		.label-s { bottom: 2px; left: 50%; transform: translateX(-50%); }
		.label-e { right: 4px; top: 50%; transform: translateY(-50%); }
		.label-w { left: 4px; top: 50%; transform: translateY(-50%); }
		
    </style>
</head>
<body>

    <div class="header-container">
        <h1>
            <img src="logo.jpg" alt="Logo" class="title-logo" onerror="this.style.display='none'">
            <div>
                æ™Ÿè‡ªç„¶ç©ç§‘å­¸ã€€<span class="mobile-break"></span>åœ°çƒç£å ´æ¨¡æ“¬
            </div>
        </h1>
        <div class="nav-buttons">
            <a href="https://line.me/ti/g2/TTCqPpZP6lQqX1z_AUDPNm4977Dvylew3O7oBg" target="_blank" class="line-btn">
                <span>ğŸ‘‰</span>åŠ  LINE æå•
            </a>       
        </div>
    </div>

    <div id="simulation-area">
        <div class="simulation-container">
            <canvas id="simCanvas"></canvas>
            <div class="internal-instruction">ğŸ’¡ è«‹ä»»æ„ç§»å‹•ç£é‡</div>
            <div class="controls">
                <div class="toggle-btn active" id="btn-magnet" onclick="toggleLayer('magnet')">åœ°ç£</div>
            </div>
			<div class="radar-widget">
    			<div class="radar-label label-n">N</div>
				<div class="radar-label label-e">E</div>
				<div class="radar-label label-s">S</div>
				<div class="radar-label label-w">W</div>
			</div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('simCanvas');
        const ctx = canvas.getContext('2d');
        
        const LOGICAL_SIZE = 1000;
        const R_EARTH = 320; 
        const ORBIT_R = R_EARTH + 75; 

        const FONTS = {
            pole: "bold 50px Arial",        
            label: "bold 36px Microsoft JhengHei", 
            geo: "bold 36px Microsoft JhengHei"    
        };

        const state = { magnet: true };
        const MAG_TILT = -11.9 * (Math.PI / 180); 
        
        // åˆå§‹ä½ç½®è¨­å®šåœ¨å³å´èµ¤é“
        let compassPos = { x: ORBIT_R, y: 0 }; 
        let compassAngle = -Math.PI / 2; 
        let isDragging = false;
        let flowParticles = [];
        
        let renderScale = 1;
        let renderOffsetX = 0;
        let renderOffsetY = 0;

        function resize() {
            const container = document.querySelector('.simulation-container');
            const w = container.clientWidth;
            const h = container.clientHeight;
            const dpr = window.devicePixelRatio || 1;
            canvas.width = w * dpr;
            canvas.height = h * dpr;
            ctx.scale(dpr, dpr);
            canvas.style.width = w + 'px';
            canvas.style.height = h + 'px';
            const minDim = Math.min(w, h);
            renderScale = (minDim * 0.95) / LOGICAL_SIZE;
            renderOffsetX = w / 2;
            renderOffsetY = h / 2;
        }
        window.addEventListener('resize', resize);
        
        function init() {
            resize(); 
            for(let i=0; i<60; i++) {
                flowParticles.push({
                    t: Math.random(),
                    lineIndex: Math.floor(Math.random() * 6), 
                    speed: 0.002 + Math.random() * 0.003
                });
            }
            // ç¢ºä¿åˆå§‹ä½ç½®æ­£ç¢º (å³å´)
            updateCompassPhysics(ORBIT_R, 0); 
            requestAnimationFrame(loop);
        }

        function loop() {
            update();
            draw();
            requestAnimationFrame(loop);
        }

        function update() {
            for (let p of flowParticles) {
                p.t += p.speed;
                if(p.t > 1) p.t = 0;
            }
        }

        function draw() {
            const w = canvas.width / (window.devicePixelRatio || 1);
            const h = canvas.height / (window.devicePixelRatio || 1);
            ctx.clearRect(0, 0, w, h);

            drawStars(w, h);

            ctx.save();
            ctx.translate(renderOffsetX, renderOffsetY);
            ctx.scale(renderScale, renderScale);

            drawEarth();
            drawGeoMarkers(); 
            
            ctx.save(); 
            ctx.rotate(MAG_TILT); 
                if (state.magnet) {
                    drawInternalMagnet();   
                    drawMagneticFields();   
                    drawMagAxis();          
                }
            ctx.restore(); 

            drawCompassClean();
            ctx.restore(); 
        }

        function drawStars(w, h) {
            ctx.fillStyle = "rgba(255,255,255,0.6)";
            const starCount = 40;
            let rand = (n) => { return Math.abs(Math.sin(n * 12.9898) * 43758.5453) % 1; };
            for(let i=0; i<starCount; i++) {
                const x = rand(i) * w;
                const y = rand(i*2) * h;
                const r = rand(i*3) * 1.5 + 0.5;
                ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.fill();
            }
        }

        function drawEarth() {
            const grad = ctx.createRadialGradient(0, 0, R_EARTH, 0, 0, R_EARTH + 50);
            grad.addColorStop(0, "rgba(0, 150, 255, 0.3)");
            grad.addColorStop(1, "rgba(0, 150, 255, 0)");
            ctx.fillStyle = grad;
            ctx.beginPath(); ctx.arc(0, 0, R_EARTH + 50, 0, Math.PI*2); ctx.fill();

            ctx.fillStyle = state.magnet ? "rgba(10, 20, 35, 0.9)" : "#0b1d2e";
            ctx.strokeStyle = "#2980b9";
            ctx.lineWidth = 3;
            ctx.beginPath(); ctx.arc(0, 0, R_EARTH, 0, Math.PI * 2); ctx.fill(); ctx.stroke();

            ctx.strokeStyle = "rgba(255, 255, 255, 0.1)";
            ctx.lineWidth = 1;
            ctx.beginPath(); ctx.moveTo(0, -R_EARTH); ctx.lineTo(0, R_EARTH); ctx.stroke();
            ctx.beginPath(); ctx.ellipse(0, 0, R_EARTH, R_EARTH*0.35, 0, 0, Math.PI*2); ctx.stroke();
        }

        function drawGeoMarkers() {
            const R_GEO_LABEL_Y = R_EARTH + 35; 
            const R_GEO_LABEL_X = 150;          
            const AXIS_LEN = R_EARTH + 140; 

            // [ä¿®æ”¹é» A] ç·šæ¢é¡è‰²èˆ‡é€æ˜åº¦ (0.3 ç‚ºé€æ˜åº¦)
			ctx.strokeStyle = "rgba(255,255,255,0.3)";
            ctx.lineWidth = 2; // è‹¥è¦ºå¾—å¤ªç´°ï¼Œå¯æ”¹æˆ 4 æˆ– 5
            ctx.setLineDash([15, 15]); // è‹¥è¦æ›´ç–é¬†ï¼Œå¯æ”¹æˆ [15, 15]ï¼›è‹¥è¦å¯¦ç·šï¼Œæ”¹æˆ []
            ctx.beginPath(); ctx.moveTo(0, -AXIS_LEN); ctx.lineTo(0, AXIS_LEN); ctx.stroke();
            ctx.setLineDash([]);
            
            ctx.fillStyle = "#fff";
            ctx.font = FONTS.label;
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText("è‡ªè½‰è»¸", 0, -AXIS_LEN - 30); 

            ctx.fillStyle = "rgba(255,255,255,0.8)";
            ctx.fillRect(-3, -R_EARTH-3, 6, 6);
            ctx.fillRect(-3, R_EARTH-3, 6, 6);

            ctx.font = FONTS.geo;
            
            ctx.textAlign = "left"; 
            ctx.fillText("åœ°ç†åŒ—æ¥µ(æ­£åŒ—)", R_GEO_LABEL_X, -R_GEO_LABEL_Y); 
            drawCuteArrow(0, -R_EARTH - 5, R_GEO_LABEL_X - 10, -R_GEO_LABEL_Y, "#fff");

            ctx.textAlign = "right"; 
            ctx.fillText("åœ°ç†å—æ¥µ", -R_GEO_LABEL_X, R_GEO_LABEL_Y);
            drawCuteArrow(0, R_EARTH + 5, -R_GEO_LABEL_X + 10, R_GEO_LABEL_Y, "#fff");
        }

        function drawInternalMagnet() {
            const w = 70, h = 380;
            ctx.fillStyle = "#27ae60"; ctx.fillRect(-w/2, -h/2, w, h/2);
            ctx.strokeStyle = "#fff"; ctx.lineWidth=2; ctx.strokeRect(-w/2, -h/2, w, h/2);
            ctx.fillStyle = "#c0392b"; ctx.fillRect(-w/2, 0, w, h/2);
            ctx.strokeRect(-w/2, 0, w, h/2);

            drawLabelAt(0, -h/4, "S", FONTS.pole, "#fff");
            drawLabelAt(0, h/4, "N", FONTS.pole, "#fff");
            
            const northMarkerY = -R_EARTH;
            const southMarkerY = R_EARTH;

            ctx.beginPath(); ctx.fillStyle = "#2ecc71"; 
            ctx.arc(0, northMarkerY, 8, 0, Math.PI*2); ctx.fill(); ctx.stroke();
            
            ctx.beginPath(); ctx.fillStyle = "#e74c3c"; 
            ctx.arc(0, southMarkerY, 8, 0, Math.PI*2); ctx.fill(); ctx.stroke();

            const labelNx = -150; 
            const labelNy = -R_EARTH - 35;
            const labelSx = 150;  
            const labelSy = R_EARTH + 35;

            drawLabelAt(labelNx, labelNy, "åœ°ç£åŒ—æ¥µ", FONTS.label, "#f1c40f");
            drawLabelAt(labelSx, labelSy, "åœ°ç£å—æ¥µ", FONTS.label, "#f1c40f");

            drawCuteArrow(0, northMarkerY - 10, labelNx + 70, labelNy + 10, "#f1c40f"); 
            drawCuteArrow(0, southMarkerY + 10, labelSx - 70, labelSy - 10, "#f1c40f"); 
        }

        function drawCuteArrow(x1, y1, x2, y2, color) {
            ctx.beginPath();
            ctx.strokeStyle = color;
            ctx.lineWidth = 3; // å¯åŠ ç²—è‡³ 5 æˆ– 6
            
            const cpX = (x1 + x2) / 2;
            const curvature = (x2 - x1) * 0.2; 
            const cpY = y1 + Math.abs(curvature) * (y1 < 0 ? 0.2 : -0.2); 
            
            ctx.moveTo(x1, y1);
            ctx.quadraticCurveTo(cpX, cpY, x2, y2);
            ctx.stroke();

            // ä¸‹é¢é€™æ®µæ§åˆ¶ç®­é ­çš„ã€Œä¸‰è§’å½¢é ­éƒ¨ã€å¤§å°
			ctx.save();
            ctx.translate(x2, y2);
            
			const angle = Math.atan2(y2 - cpY, x2 - cpX);
            ctx.rotate(angle);
            
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.moveTo(0, 0);
			
			// [ä¿®æ”¹é» B] ç®­é ­é ­éƒ¨å¤§å°
			// -12 æ˜¯é•·åº¦ï¼Œ7 æ˜¯å¯¬åº¦çš„ä¸€åŠ
			// è‹¥è¦è®Šå¤§ï¼Œå¯æ”¹æˆ (-20, -12) èˆ‡ (-20, 12)
            ctx.lineTo(-20, -12); 
            ctx.lineTo(-20, 12);
            ctx.fill();
            ctx.restore();
        }

        function drawMagAxis() {
            ctx.beginPath();
            ctx.strokeStyle = "rgba(241, 196, 15, 0.6)"; 
            ctx.setLineDash([15, 15]); ctx.lineWidth = 2;
            const axisLen = R_EARTH + 140;
            ctx.moveTo(0, -axisLen); 
            ctx.lineTo(0, axisLen); 
            ctx.stroke();
            ctx.setLineDash([]);
            
            drawLabelAt(0, -axisLen - 30, "ç£è»¸", FONTS.label, "#f1c40f", "center");
        }

        function drawLabelAt(lx, ly, text, font, color, align = "center") {
            ctx.save();
            ctx.translate(lx, ly);    
            ctx.rotate(-MAG_TILT); 
            
            ctx.font = font;
            ctx.fillStyle = color;
            ctx.textAlign = align;
            ctx.textBaseline = "middle";
            ctx.shadowColor = "rgba(0,0,0,0.8)";
            ctx.shadowBlur = 4;
            
            ctx.fillText(text, 0, 0);
            ctx.restore();
        }

        function drawMagneticFields() {
            ctx.strokeStyle = "rgba(0, 210, 255, 0.2)";
            ctx.lineWidth = 2;
            const scales = [1.6, 2.5, 4.0]; 
            scales.forEach((s, idx) => {
                drawSingleLine(-s, idx);      
                drawSingleLine(s, idx + 3);   
            });
        }

        function drawSingleLine(scaleX, idx) {
            const startY = R_EARTH; 
            const endY = -R_EARTH;
            const cpX = R_EARTH * scaleX;
            
            const bulge = Math.abs(cpX) * 0.6;
            const cpY_Start = startY + bulge; 
            const cpY_End = endY - bulge;    

            ctx.beginPath();
            ctx.moveTo(0, startY);
            ctx.bezierCurveTo(cpX, cpY_Start, cpX, cpY_End, 0, endY);
            ctx.stroke();

            ctx.fillStyle = "rgba(255,255,255,0.9)";
            for(let p of flowParticles) {
                if(p.lineIndex === idx) {
                    const t = p.t;
                    const x = bezier(0, cpX, cpX, 0, t);
                    const y = bezier(startY, cpY_Start, cpY_End, endY, t);
                    ctx.beginPath(); ctx.arc(x, y, 3, 0, Math.PI*2); ctx.fill();
                }
            }
        }
        function bezier(p0, p1, p2, p3, t) {
            const m = 1-t;
            return m*m*m*p0 + 3*m*m*t*p1 + 3*m*t*t*p2 + t*t*t*p3;
        }

        // =========================================
        // [æ ¸å¿ƒä¿®æ­£] å‘é‡è¨ˆç®—èˆ‡å€åŸŸæ··åˆ
        // =========================================
        function updateCompassPhysics(worldX, worldY) {
            // 1. è½‰æ›è‡³ç£éµåº§æ¨™ç³»
            const cosT = Math.cos(-MAG_TILT);
            const sinT = Math.sin(-MAG_TILT);
            const rx = worldX * cosT - worldY * sinT;
            const ry = worldX * sinT + worldY * cosT;
            const r2 = rx*rx + ry*ry;
            const r = Math.sqrt(r2);
            
            // 2. è¨ˆç®—çœŸå¯¦ç£å ´å‘é‡ (Real Dipole B)
            // åœ¨æˆ‘å€‘çš„æ¨¡å‹ä¸­ï¼Œå¤–éƒ¨ç£åŠ›ç·šæµå‘ç‚º Bottom(Red N) -> Top(Green S)
            // é€™ç›¸ç•¶æ–¼åœ¨èµ¤é“è™•ï¼Œç£å ´å‘é‡æŒ‡å‘ -Y (ä¸Š)
            // å¶æ¥µå­å…¬å¼ B = 3(m.r)r/r^5 - m/r^3
            // é€™è£¡ m æŒ‡å‘ (0, 1) [å‘ä¸‹] æ‰èƒ½ç”¢ç”Ÿå‘ä¸Šçš„èµ¤é“å ´? 
            // è®“æˆ‘å€‘è§€å¯Ÿï¼šm=(0,1), èµ¤é“(1,0), m.r=0, B = -(0,1) = (0,-1) [å‘ä¸Š]. å°äº†ã€‚
            // æª¢æŸ¥æ¥µé»(0,1, Bottom). m.r=1. B=3(1)(0,1)-(0,1)=(0,2) [å‘ä¸‹/å‘å¤–]. å°äº†(ç´…æ¥µå™´å‡º)ã€‚
            // æª¢æŸ¥æ¥µé»(0,-1, Top). m.r=-1. B=3(-1)(0,-1)-(0,1)=(0,3)-(0,1)=(0,2)? 
            // Wait. r=(0,-1). 3(-1)(0,-1) = (0,3). - (0,1) = (0,2) [å‘ä¸‹/å‘å…§]. å°äº†(ç¶ æ¥µå¸å…¥)ã€‚
            
            // æ‰€ä»¥ m = (0, 1) çš„å¶æ¥µå ´å…¬å¼ï¼š
            // Bx = 3 * rx * ry / r^5  (çœç•¥åˆ†æ¯ r^5, åªçœ‹æ–¹å‘) -> 3xy
            // By = (3 * ry^2 - r^2) / r^5 -> 2y^2 - x^2
            // è¨˜å¾—è¦æ­£è¦åŒ–
            
            const bx = 3 * rx * ry;
            const by = 2 * ry * ry - rx * rx;
            const bLen = Math.sqrt(bx*bx + by*by);
            const bx_norm = bx / bLen;
            const by_norm = by / bLen;

            // 3. è¨ˆç®—ã€ŒæŒ‡å‘åŒ—æ–¹çš„åˆ‡ç·šã€ (Tangent North)
            // åœ¨é€™å€‹æ¨¡å‹ï¼ŒåŒ—æ–¹ = ç¶ æ¥µ = è² Yè»¸æ–¹å‘
            // åœ¨èµ¤é“å³å´ (x>0), åŒ—æ˜¯ -y. T = (0, -1)
            // åœ¨èµ¤é“å·¦å´ (x<0), åŒ—æ˜¯ -y. T = (0, -1)
            // åœ¨ä»»æ„é» (rx, ry), åˆ‡ç·šå‚ç›´æ–¼åŠå¾‘. T dot R = 0.
            // T = (-ry, rx) æˆ– (ry, -rx).
            // æˆ‘å€‘å¸Œæœ› T çš„ y åˆ†é‡ç›¡é‡æ˜¯è² çš„ (æŒ‡å‘åŒ—æ–¹).
            // ç•¶ x>0, T=(0,-1) -> (ry, -rx) => (0, -x). ok.
            // ç•¶ x<0, T=(0,-1) -> (-ry, rx) => (0, x). xæ˜¯è² çš„,æ‰€ä»¥æ˜¯è² . ok.
            // ç¨å¾®è¤‡é›œï¼Œæˆ‘å€‘ç”¨æœ€ç°¡å–®çš„ã€Œä¿®æ­£åœ°è¡¨å¹³è¡Œã€æ¦‚å¿µï¼š
            // å¹³è¡Œåœ°è¡¨ = å‚ç›´æ–¼åŠå¾‘.
            // æˆ‘å€‘è¦é¸é‚£å€‹ã€Œè·Ÿ B å‘é‡å¤¾è§’è¼ƒå°ã€çš„åˆ‡ç·šæ–¹å‘
            
            const t1x = -ry; const t1y = rx;
            const t2x = ry;  const t2y = -rx;
            
            // é»ç©åˆ¤æ–·å“ªå€‹è·Ÿ B åŒå‘
            const dot1 = t1x*bx_norm + t1y*by_norm;
            let tx_final, ty_final;
            
            if (dot1 > 0) { tx_final = t1x; ty_final = t1y; }
            else { tx_final = t2x; ty_final = t2y; }
            
            const tLenFinal = Math.sqrt(tx_final*tx_final + ty_final*ty_final);
            const tx_norm = tx_final / tLenFinal;
            const ty_norm = ty_final / tLenFinal;

            // 4. å€åŸŸæ··åˆ (Lerp)
            // è¨ˆç®—ç£ç·¯åº¦ absSinLat = |y| / r
            const absSinLat = Math.abs(ry) / r;
            
            let factor = 0; // 0=Tangent, 1=Dipole
            // < 30åº¦ (sin 0.5): ä¿æŒå¹³è¡Œ
            // > 65åº¦ (sin 0.9): çœŸå¯¦ç‰©ç†
            if (absSinLat < 0.5) factor = 0;
            else if (absSinLat > 0.985) factor = 1;
            else factor = (absSinLat - 0.5) / (0.485);

            // 5. æ··åˆ
            const final_x = tx_norm * (1 - factor) + bx_norm * factor;
            const final_y = ty_norm * (1 - factor) + by_norm * factor;

            // 6. è½‰å›ä¸–ç•Œè§’åº¦
            const angle_mag = Math.atan2(final_y, final_x);
            compassAngle = angle_mag + MAG_TILT;
        }

        function drawCompassClean() {
            const cx = compassPos.x;
            const cy = compassPos.y;

            if (isDragging) {
                // æ‹–æ›³æ™‚ï¼Œé¡¯ç¤ºæŒ‡å‘åœ“å¿ƒçš„è¼”åŠ©ç·š
                ctx.save();
                ctx.strokeStyle = "rgba(255, 50, 50, 0.3)";
                ctx.setLineDash([5, 5]); ctx.lineWidth = 1;
                ctx.beginPath(); ctx.moveTo(cx, cy); ctx.lineTo(0, 0); ctx.stroke();
                ctx.restore();
            }

            ctx.save();
            ctx.translate(cx, cy);
            ctx.rotate(compassAngle);
            
			// size: ç®­é ­å°¾éƒ¨çš„å¯¬åº¦ (æ•¸å€¼è¶Šå¤§è¶Šèƒ–)
			// len:  ç®­é ­å°–ç«¯çš„é•·åº¦ (æ•¸å€¼è¶Šå¤§è¶Šé•·)
            const size = 10, len = 50; 
            ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(-size, -14); ctx.lineTo(len, 0); ctx.lineTo(-size, 14);
            ctx.fillStyle = "#ff3333"; ctx.fill();
            ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(-size, -14); ctx.lineTo(-len, 0); ctx.lineTo(-size, 14);
            ctx.fillStyle = "#e0e0e0"; ctx.fill();
            ctx.fillStyle = "#111"; ctx.beginPath(); ctx.arc(0,0,5,0,Math.PI*2); ctx.fill();
            ctx.save(); ctx.rotate(-Math.PI/2); ctx.fillStyle = "rgba(255,255,255,0.9)";
            ctx.font = "bold 28px sans-serif"; ctx.fillText("N", 24, 36); ctx.restore();
            ctx.restore();
        }

        window.toggleLayer = function(key) {
            if (key === 'magnet') {
                state.magnet = !state.magnet;
                const btn = document.getElementById('btn-magnet');
                if(btn) btn.classList.toggle('active');
            }
        };

        function getLogicalPos(e) {
            const rect = canvas.getBoundingClientRect();
            const clientX = e.touches && e.touches.length > 0 ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches && e.touches.length > 0 ? e.touches[0].clientY : e.clientY;
            if (clientX === undefined) return {x:0, y:0};
            const screenX = clientX - rect.left;
            const screenY = clientY - rect.top;
            return {
                x: (screenX - renderOffsetX) / renderScale,
                y: (screenY - renderOffsetY) / renderScale
            };
        }

        function onDown(e) {
            isDragging = true;
            const pos = getLogicalPos(e);
            updateCompassPosition(pos.x, pos.y);
            e.preventDefault(); 
        }

        function onMove(e) {
            if(!isDragging) return;
            e.preventDefault();
            const pos = getLogicalPos(e);
            updateCompassPosition(pos.x, pos.y);
        }
        
        function updateCompassPosition(tx, ty) {
            // [ä¿®æ­£] å¼·åˆ¶é–å®šåœ¨åœ“å½¢è»Œé“ (ä½¿ç”¨ atan2 å–å¾—è§’åº¦ï¼Œç„¶å¾Œé‡è¨­åŠå¾‘)
            const ang = Math.atan2(ty, tx);
            compassPos.x = Math.cos(ang) * ORBIT_R;
            compassPos.y = Math.sin(ang) * ORBIT_R;
            
            updateCompassPhysics(compassPos.x, compassPos.y);
        }

        function onUp(e) {
            isDragging = false;
        }

        canvas.addEventListener('mousedown', onDown);
        window.addEventListener('mousemove', onMove);
        window.addEventListener('mouseup', onUp);
        canvas.addEventListener('touchstart', onDown, {passive: false});
        window.addEventListener('touchmove', onMove, {passive: false});
        window.addEventListener('touchend', onUp);

        init();
    </script>
</body>
</html>