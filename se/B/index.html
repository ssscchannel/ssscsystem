<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>æ™Ÿè‡ªç„¶è¼”åŠ©ç³»çµ±ã€€æ„Ÿæ‡‰èµ·é›»</title>
    
    <style>
        /* =========================================
           1. å…¨å±€è¨­å®šï¼šå¼·åˆ¶ä¸€é å¼ (No Scroll) - ç¹¼æ‰¿è‡ªå°ˆæ¡ˆA
           ========================================= */
        :root {
            --ground-color: #27ae60; /* å°ˆæ¡ˆB ç‰¹æœ‰çš„æ¥åœ°è‰² */
        }

        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100vh;   
            height: 100dvh;  
            overflow: hidden; 
            
            display: flex;
            flex-direction: column;
            align-items: center; 
            
            background-image: url('page.jpg'); 
            background-size: cover;
            background-position: center;
            background-color: #000;
            font-family: 'Microsoft JhengHei', 'Segoe UI', sans-serif;
            touch-action: none; /* ç¦æ­¢é è¨­è§¸æ§è¡Œç‚º */
            user-select: none;  /* ç¦æ­¢é¸å–æ–‡å­— */
        }

        /* =========================================
           2. æ¨™æº–æ¨™é¡Œå€ (Header Container) - ç¹¼æ‰¿è‡ªå°ˆæ¡ˆA
           ========================================= */
        .header-container {
            flex-shrink: 0;
            width: 97%;
            box-sizing: border-box;
            max-width: 800px;
            
            display: flex;
            justify-content: space-between; 
            align-items: center;
            
            padding: 8px 15px;
            margin-top: 5px;
            margin-bottom: 8px;
            
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(5px);
            border-radius: 12px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.15);
            z-index: 1000;
        }

        .header-container h1 {
            margin: 0;
            font-size: 1.1rem;
            color: #333;
            line-height: 1.3;
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 10px;
            white-space: nowrap;
        }

        .title-logo {
            height: 36px;
            width: auto;
            border-radius: 4px;
        }

        .header-btn {
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 6px 12px;
            background: #06c755;
            color: white;
            font-size: 0.9rem;
            font-weight: bold;
            border-radius: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            transition: transform 0.1s, background 0.2s;
            white-space: nowrap;
        }
        
        .header-btn:active {
            transform: scale(0.95);
        }

        .header-btn span {
            margin-right: 4px;
        }

        /* =========================================
           3. ä¸­é–“æ¨¡æ“¬å€ (Main Simulation)
           ========================================= */
        #sim-container {
            flex: 1; 
            width: 100%;
            position: relative;
            overflow: hidden;
        }

        canvas { display: block; width: 100%; height: 100%; }

        /* æµ®å‹•æç¤ºæ¨™ç±¤ - åŸºç¤æ¨£å¼ç¹¼æ‰¿è‡ª Aï¼Œä½†åœ¨ä¸‹æ–¹æ“´å…… B çš„ç‹€æ…‹ */
        .instruction-tag {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.95);
            padding: 8px 24px;
            border-radius: 50px;
            font-size: 0.95rem;
            color: #555;
            font-weight: 600;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            pointer-events: none; 
            white-space: nowrap;
            backdrop-filter: blur(5px);
            border: 2px solid rgba(0,0,0,0.05);
            transition: all 0.3s ease;
            z-index: 10;
        }

        /* --- å°ˆæ¡ˆB ç‰¹æœ‰ç‹€æ…‹æ¨£å¼æ•´åˆ --- */
        .instruction-tag.step-active {
            color: #2c3e50;
            border-color: #3498db;
            background: #fff;
            transform: translateX(-50%) scale(1.02);
        }
        
        .instruction-tag.success {
            color: #fff;
            background: var(--ground-color);
            border-color: var(--ground-color);
            box-shadow: 0 4px 20px rgba(39, 174, 96, 0.4);
        }

        /* =========================================
           4. åº•éƒ¨æ§åˆ¶å€ (Footer Controls) - åš´æ ¼çµ±ä¸€ç‰ˆ
           ========================================= */
        .controls {
            flex: 0 0 auto;
            width: 100%;
            box-sizing: border-box;
            
            /* çµ±ä¸€é«˜åº¦èˆ‡èƒŒæ™¯ */
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(5px);
            border-top: 1px solid rgba(0,0,0,0.1);
            
            /* çµ±ä¸€å…§è·ï¼šä¸Šä¸‹ 10pxï¼Œå·¦å³ 15px */
            padding: 10px 15px;
            padding-bottom: calc(10px + env(safe-area-inset-bottom, 0px));
            
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 1000;
        }

        .controls-left { display: flex; align-items: center; }
        .controls-right { display: flex; align-items: center; }

        .switch-capsule {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            background: #f1f3f5;
            border-radius: 100px;
            box-shadow: inset 0 2px 6px rgba(0,0,0,0.06);
            padding: 5px 15px; 
            gap: 10px; /* çµ±ä¸€é–“è· */
        }

        /* çµ±ä¸€æ‰€æœ‰åŠŸèƒ½æŒ‰éˆ•ç‚ºåœ“å½¢ 44px */
        .btn-toggle {
            width: 44px; height: 44px;
            border: none; border-radius: 50%;
            font-size: 1.5rem; font-weight: 800;
            cursor: pointer;
            background: transparent; color: #bdc3c7;
            display: flex; align-items: center; justify-content: center;
            transition: all 0.2s;
            flex-shrink: 0; /* ç¦æ­¢è¢«å£“ç¸® */
        }
        
        .btn-toggle:active { transform: scale(0.95); }
        
        /* æ­£è² é›»æŒ‰éˆ•ç‹€æ…‹ */
        .btn-toggle.active-neg { background: #3498db; color: white; box-shadow: 0 4px 12px rgba(52, 152, 219, 0.4); }
        .btn-toggle.active-pos { background: #e74c3c; color: white; box-shadow: 0 4px 12px rgba(231, 76, 60, 0.4); }
        
        /* æ¥åœ°æŒ‰éˆ•ç‹€æ…‹ (å°ˆæ¡ˆBå°ˆç”¨) */
        .btn-toggle.active-ground { 
            background: var(--ground-color); 
            color: white; 
            box-shadow: 0 4px 12px rgba(39, 174, 96, 0.5); 
        }

        /* é‡ç½®æŒ‰éˆ•å¾®èª¿ (å°ˆæ¡ˆBå°ˆç”¨) */
        .btn-reset-icon {
            font-size: 1.4rem;
            color: #e74c3c;
        }
        .btn-reset-icon:hover { background: rgba(231, 76, 60, 0.1); }

        .deck-label { font-size: 0.9rem; font-weight: 700; color: #666; white-space: nowrap; margin-right: 5px; }
        .divider { width: 1px; height: 24px; background: #cbd5e0; margin: 0 2px; }

        /* è¿”å›æŒ‰éˆ•çµ±ä¸€ */
        .btn-return {
            width: 44px; height: 44px;
            border-radius: 50%;
            background: #fff;
            color: #555;
            display: flex; align-items: center; justify-content: center;
            text-decoration: none;
            font-size: 1.4rem;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            border: 1px solid rgba(0,0,0,0.05);
            transition: all 0.2s;
        }
        .btn-return:active { transform: scale(0.9); background: #f0f0f0; }

        /* RWD: æ‰‹æ©Ÿç›´å¼æ™‚ï¼Œæ¨™é¡Œéé•·è‡ªå‹•æ›è¡Œ */
        .mobile-break { display: none; }
        
        @media (max-width: 600px) {
            .mobile-break { display: block; height: 0; }
            .header-container h1 { font-size: 1rem; }
            .header-btn { padding: 5px 10px; font-size: 0.85rem; }
            .header-btn span { display: none; } /* æ‰‹æ©Ÿç‰ˆå¤ªçª„æ™‚ï¼Œéš±è—æ‰‹æŒ‡åœ–ç¤º */
			.instruction-bar {
    			font-size: 0.8rem; /* æ‰‹æ©Ÿå­—é«”ç¸®å° */
				padding: 5px 15px;
				width: 90%; /* æ‰‹æ©Ÿä¸Šå¯¬åº¦ç¨å¾®æ”¾å¯¬ */
				margin-top: 5px; /* æ‰‹æ©Ÿç‰ˆä¸ä½¿ç”¨è² é‚Šè·ï¼Œé¿å…å¤ªæ“æ“  */
				margin-bottom: 10px;
				flex-direction: row; /* ä¿æŒæ°´å¹³æ’åˆ— */
				flex-wrap: nowrap; /* ç›¡é‡ä¸æ›è¡Œï¼Œè‹¥å­—å¤ªå¤šæœƒè‡ªå‹•ç¸®å° */
				}
        }
    </style>
</head>
<body>

    <div class="header-container">
        <h1>
            <img src="logo.jpg" alt="Logo" class="title-logo" onerror="this.style.display='none'">
            <div>
                æ™Ÿè‡ªç„¶è¼”åŠ©ç³»çµ±ã€€æ„Ÿæ‡‰èµ·é›»
            </div>
        </h1>
        <div class="nav-buttons">
            <a href="https://line.me/ti/g2/TTCqPpZP6lQqX1z_AUDPNm4977Dvylew3O7oBg" target="_blank" class="header-btn">
                <span>ğŸ‘‰</span>åŠ  LINE æå•
            </a>       
        </div>
    </div>

    <div id="sim-container">
        <div class="instruction-tag" id="infoTag">æ­¥é©Ÿ1ï¼šè«‹æ‹–æ›³å¸¶é›»æ£’é è¿‘é‡‘å±¬çƒ</div>
        <canvas id="simCanvas"></canvas>
    </div>

    <div class="controls">
        <div class="controls-left">
            <div class="switch-capsule">
                <span class="deck-label">å¸¶é›»æ£’</span>
                
                <button class="btn-toggle active-neg" id="btnNeg" onclick="APP.setRod(-1)">ï¼</button>
                <button class="btn-toggle" id="btnPos" onclick="APP.setRod(1)">ï¼‹</button>
                
                <div class="divider"></div>
                
                <button class="btn-toggle" id="btnGround" onclick="APP.toggleGround()" title="æ¥åœ°">
                    ğŸ–
                </button>
                
                <button class="btn-toggle btn-reset-icon" onclick="APP.reset()" title="é‡ç½®">
                    â†º
                </button>
            </div>
        </div>

        <div class="controls-right">
            <a href="index.html" class="btn-return" title="è¿”å›å¯¦é©—å®¤">â†©</a>
        </div>
    </div>

    <script>
        /**
         * Project B: Induction Charging (Formatted for Unified System)
         * é‚è¼¯èˆ‡ç‰©ç†é‹ç®—å®Œå…¨ä¿ç•™ï¼Œåƒ…é‡å° DOM å®¹å™¨ ID èˆ‡ Resize æ–¹å¼é€²è¡Œé©é…ã€‚
         */
        const APP = {
            canvas: null,
            ctx: null,
            wrapper: null,
            width: 0,
            height: 0,
            dpr: 1,

            conductor: { x: 0, y: 0, r: 0 },
            rod: { x: 0, y: 0, charge: -1, dragging: false, angle: 0 }, 
            
            particles: [], 
            protons: [],   
            flowParticles: [], 
            
            state: {
                inductionLevel: 0,
                isGrounded: false,
                flowTimer: 0
            },

            CONFIG: {
                radiusBase: 90,     
                particleSize: 15,
                k_rod: 120000,
                k_self: 8000, 
                damping: 0.85, 
                rodLen: 100,        
                rodW: 34,           
                gap: 50,            
                inductionThreshold: 160,
                groundY: 0,
                wireX: 0
            },

            init: function() {
                // ä¿®æ”¹ï¼šé©é…æ–°æ¶æ§‹çš„å®¹å™¨ ID
                this.wrapper = document.getElementById('sim-container');
                this.canvas = document.getElementById('simCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.dpr = window.devicePixelRatio || 1;

                // ä¿æŒåŸæœ‰çš„äº‹ä»¶ç¶å®š
                const bind = (evts, handler) => evts.forEach(e => this.canvas.addEventListener(e, handler, {passive: false}));
                bind(['mousedown', 'mousemove', 'mouseup', 'mouseleave'], e => this.handleMouse(e));
                bind(['touchstart', 'touchmove', 'touchend'], e => this.handleTouch(e));
                
                // å¢åŠ è¦–çª— Resize ç›£è½
                window.addEventListener('resize', () => this.resize());

                this.resize();
                this.loop();
            },

            resize: function() {
                // ä¿®æ”¹ï¼šæ”¹ç‚ºè®€å– flex å®¹å™¨çš„å¤§å°ï¼Œä»¥æ”¯æ´å…¨è¢å¹•é©é…
                const rect = this.wrapper.getBoundingClientRect();
                this.width = rect.width;
                this.height = rect.height;
                
                this.canvas.width = this.width * this.dpr;
                this.canvas.height = this.height * this.dpr;
                this.ctx.scale(this.dpr, this.dpr);

                // ç‰©ç†ä½ç½®è¨ˆç®—ç¶­æŒåŸé‚è¼¯ï¼Œä½†åŸºæº–é»æ”¹ç‚ºå‹•æ…‹ä¸­å¿ƒ
                this.conductor.x = this.width / 2;
                this.conductor.y = this.height / 2 - 60; 
                this.CONFIG.groundY = this.height - 40; 
                
                // ç¸®æ”¾æ¯”ä¾‹è¨ˆç®—
                let scale = Math.min(this.width, this.height) / 400;
                this.conductor.r = this.CONFIG.radiusBase * scale;
                this.CONFIG.wireX = this.conductor.x + this.conductor.r + 30; 
                
                this.rodSize = {
                    L: this.CONFIG.rodLen * scale,
                    W: this.CONFIG.rodW * scale
                };

                if (this.protons.length === 0) {
                    this.initParticles();
                    this.rod.x = this.width * 0.85; 
                    this.rod.y = this.height * 0.85;
                }
            },

            reset: function() {
                this.state.isGrounded = false;
                this.state.flowTimer = 0;
                this.flowParticles = [];
                this.rod.x = this.width * 0.85;
                this.rod.y = this.height * 0.85;
                this.rod.angle = -Math.PI/4;
                this.initParticles();
                this.updateUI();
            },

            initParticles: function() {
                this.particles = [];
                this.protons = [];
                const {x, y, r} = this.conductor;
                const offset = r * 0.4;

                const pos = [
                    {x: x-offset, y: y-offset}, {x: x+offset, y: y-offset},
                    {x: x-offset, y: y+offset}, {x: x+offset, y: y+offset}
                ];

                pos.forEach(p => {
                    this.protons.push({x: p.x, y: p.y});
                    this.particles.push({
                        x: p.x + (Math.random()-0.5)*5,
                        y: p.y + (Math.random()-0.5)*5,
                        vx: 0, vy: 0
                    });
                });
            },

            update: function() {
                let dxRod = this.conductor.x - this.rod.x;
                let dyRod = this.conductor.y - this.rod.y;
                this.rod.angle = Math.atan2(dyRod, dxRod); 
                let halfL = this.rodSize.L / 2;
                let tipX = this.rod.x + Math.cos(this.rod.angle) * halfL;
                let tipY = this.rod.y + Math.sin(this.rod.angle) * halfL;

                let distToCenter = Math.sqrt(dxRod*dxRod + dyRod*dyRod);
                let surfaceDist = distToCenter - this.conductor.r - halfL;
                let maxEffectDist = this.CONFIG.inductionThreshold;
                if (surfaceDist < 0) surfaceDist = 0;
                
                if (surfaceDist > maxEffectDist) {
                    this.state.inductionLevel = 0;
                } else {
                    this.state.inductionLevel = 1 - (surfaceDist / maxEffectDist);
                }

                this.updateGroundingLogic();

                // ä½¿ç”¨å‹•æ…‹å¯¬åº¦è¨ˆç®—ç‰©ç†åƒæ•¸
                const scale = this.width / 400;
                const pR = this.CONFIG.particleSize * scale;
                
                let forceMult = (this.rod.charge === 1) ? 2.5 : 1.0; 
                const rodForceBase = this.CONFIG.k_rod * scale * forceMult;
                const selfForceBase = this.CONFIG.k_self * scale;

                this.particles.forEach((p) => {
                    let fx = 0, fy = 0;
                    
                    let dx = p.x - tipX;
                    let dy = p.y - tipY;
                    let distSq = dx*dx + dy*dy;
                    
                    let minD = (this.rod.charge === 1) ? 60 : 100;
                    if (distSq < minD) distSq = minD;
                    
                    let rodF = rodForceBase / distSq;
                    let dist = Math.sqrt(distSq);

                    if (this.state.inductionLevel > 0) {
                        if (this.rod.charge === -1) { 
                            fx += (dx / dist) * rodF; fy += (dy / dist) * rodF; 
                        } else { 
                            fx -= (dx / dist) * rodF; fy -= (dy / dist) * rodF; 
                        }
                    }

                    this.particles.forEach((other) => {
                        if (p === other) return;
                        let odx = p.x - other.x;
                        let ody = p.y - other.y;
                        let od2 = odx*odx + ody*ody;
                        let od = Math.sqrt(od2);
                        if (od < 0.1) od = 0.1;
                        
                        let repF = selfForceBase / (od2 + 10);
                        fx += (odx/od) * repF;
                        fy += (ody/od) * repF;
                    });

                    p.vx = (p.vx + fx) * this.CONFIG.damping;
                    p.vy = (p.vy + fy) * this.CONFIG.damping;
                    
                    let speed = Math.sqrt(p.vx*p.vx + p.vy*p.vy);
                    if (speed > 8) {
                        p.vx = (p.vx/speed)*8;
                        p.vy = (p.vy/speed)*8;
                    }

                    p.x += p.vx;
                    p.y += p.vy;
                });

                const iterations = 3; 
                for(let k=0; k<iterations; k++) {
                    this.particles.forEach((p, i) => {
                        let cdx = p.x - this.conductor.x;
                        let cdy = p.y - this.conductor.y;
                        let cDist = Math.sqrt(cdx*cdx + cdy*cdy);
                        let limitR = this.conductor.r - pR - 2;

                        if (cDist > limitR) {
                            let ang = Math.atan2(cdy, cdx);
                            p.x = this.conductor.x + limitR * Math.cos(ang);
                            p.y = this.conductor.y + limitR * Math.sin(ang);
                            p.vx *= 0.1; 
                            p.vy *= 0.1;
                        }

                        for (let j = i + 1; j < this.particles.length; j++) {
                            let p2 = this.particles[j];
                            let dx = p.x - p2.x;
                            let dy = p.y - p2.y;
                            let dist = Math.sqrt(dx*dx + dy*dy);
                            let minDist = pR * 2 + 2; 

                            if (dist < minDist) {
                                let overlap = minDist - dist;
                                let nx = dx / dist;
                                let ny = dy / dist;
                                p.x += nx * overlap * 0.5;
                                p.y += ny * overlap * 0.5;
                                p2.x -= nx * overlap * 0.5;
                                p2.y -= ny * overlap * 0.5;
                            }
                        }
                    });
                }

                this.updateFlowParticles();
                this.updateInstruction();
            },

            updateGroundingLogic: function() {
                if (!this.state.isGrounded) return;
                if (this.state.inductionLevel < 0.2) return; 

                this.state.flowTimer++;
                if (this.state.flowTimer < 10) return; 
                
                let currentCount = this.particles.length;
                let targetCount = 4; 
                if (this.rod.charge === 1) targetCount = 8;
                if (this.rod.charge === -1) targetCount = 0;

                if (currentCount < targetCount) {
                    if (this.flowParticles.length === 0) {
                        this.spawnFlowParticle('up');
                        this.state.flowTimer = 0;
                    }
                } else if (currentCount > targetCount) {
                    if (this.flowParticles.length === 0) {
                        this.particles.pop(); 
                        this.spawnFlowParticle('down');
                        this.state.flowTimer = 0;
                    }
                }
            },

            spawnFlowParticle: function(dir) {
                let wireX = this.CONFIG.wireX;
                let startY = (dir === 'up') ? this.CONFIG.groundY : this.conductor.y;
                
                this.flowParticles.push({
                    x: wireX,
                    y: startY,
                    vy: (dir === 'up') ? -20 : 20, 
                    dir: dir,
                    active: true
                });
            },

            updateFlowParticles: function() {
                for(let i = this.flowParticles.length-1; i>=0; i--) {
                    let p = this.flowParticles[i];
                    p.y += p.vy;
                    
                    let hitSphere = (p.dir === 'up' && p.y <= this.conductor.y);
                    let hitGround = (p.dir === 'down' && p.y >= this.CONFIG.groundY);

                    if (p.active) {
                        if (hitSphere) {
                            this.particles.push({
                                x: this.conductor.x + this.conductor.r - 10,
                                y: this.conductor.y,
                                vx: -5, vy: 0
                            });
                            p.active = false;
                        } else if (hitGround) {
                            p.active = false;
                        }
                    }

                    if (p.y < this.conductor.y - 100 || p.y > this.CONFIG.groundY + 100 || !p.active) {
                        this.flowParticles.splice(i, 1);
                    }
                }
            },

            updateInstruction: function() {
                const tag = document.getElementById('infoTag');
                const level = this.state.inductionLevel;
                const grounded = this.state.isGrounded;
                const eCount = this.particles.length;
                
                let msg = "";
                let className = "instruction-tag";
                
                if (!grounded) {
                    if (level < 0.2) {
                        if (eCount === 4) {
                            msg = "æ­¥é©Ÿ1ï¼šè«‹æ‹–æ›³å¸¶é›»æ£’é è¿‘é‡‘å±¬çƒ";
                            className += " step-active";
                        } else {
                            let charge = eCount > 4 ? "è² " : "æ­£";
                            msg = `å¯¦é©—å®Œæˆï¼šé‡‘å±¬çƒå¸¶${charge}é›»`;
                            className += " success";
                        }
                    } else {
                        msg = "æ­¥é©Ÿ2ï¼šå¸¶é›»æ£’ä¸å‹•ï¼Œé»æ“Šä¸‹æ–¹ã€Œæ¥åœ°ã€";
                        className += " step-active";
                    }
                } else {
                    let isBalanced = false;
                    if (this.rod.charge === 1 && eCount === 8) isBalanced = true;
                    if (this.rod.charge === -1 && eCount === 0) isBalanced = true;
                    
                    if (isBalanced) {
                        msg = "æ­¥é©Ÿ3ï¼šè«‹ã€Œæ–·é–‹æ¥åœ°ã€é–å®šé›»è·";
                    } else {
                        msg = "æ­¥é©Ÿ3ï¼šè§€å¯Ÿé›»å­æµå‹•æ–¹å‘";
                    }
                    className += " step-active";
                }
                
                if (!grounded && level >= 0.2 && eCount !== 4) {
                    msg = "æ­¥é©Ÿ4ï¼šè«‹ç§»é–‹å¸¶é›»æ£’";
                }

                if (tag.innerText !== msg) tag.innerText = msg;
                tag.className = className;
            },

            toggleGround: function() {
                if (this.state.inductionLevel < 0.2) return;
                this.state.isGrounded = !this.state.isGrounded;
                this.updateUI();
            },

            updateUI: function() {
                const btn = document.getElementById('btnGround');
                if (this.state.isGrounded) {
                    btn.classList.add('active-ground'); // ä½¿ç”¨æ–°çš„ active-ground é¡åˆ¥
                    // ç§»é™¤æ–‡å­—ä¿®æ”¹ï¼Œä¿æŒåœ–ç¤º
                } else {
                    btn.classList.remove('active-ground');
                }
            },

            draw: function() {
                this.ctx.clearRect(0, 0, this.width, this.height);
                
                this.drawFloor();
                this.drawConductor(); 
                
                if (this.state.isGrounded) {
                    this.drawGroundSystem();
                }
                
                this.protons.forEach(p => this.drawCharge(p.x, p.y, '#e74c3c', '+'));
                this.particles.forEach(p => this.drawCharge(p.x, p.y, '#3498db', '-'));
                this.flowParticles.forEach(p => this.drawCharge(p.x, p.y, '#3498db', '-'));

                this.drawRod();
            },

            drawFloor: function() {
                const y = this.CONFIG.groundY;
                this.ctx.lineCap = 'butt';
                
                this.ctx.beginPath();
                this.ctx.moveTo(0, y);
                this.ctx.lineTo(this.width, y);
                this.ctx.strokeStyle = '#7f8c8d'; 
                this.ctx.lineWidth = 2;
                this.ctx.stroke();

                this.ctx.beginPath();
                for(let i=0; i<this.width; i+=25) {
                    this.ctx.moveTo(i, y);
                    this.ctx.lineTo(i-15, y+15);
                }
                this.ctx.strokeStyle = '#95a5a6';
                this.ctx.lineWidth = 1;
                this.ctx.stroke();
            },

            drawGroundSystem: function() {
                const y = this.CONFIG.groundY;
                const wireX = this.CONFIG.wireX;
                const {x, r} = this.conductor;
                const cy = this.conductor.y;

                this.ctx.lineCap = 'round';
                this.ctx.lineJoin = 'round';

                this.ctx.beginPath();
                this.ctx.moveTo(x + r + 20, cy); 
                this.ctx.lineTo(wireX, cy); 
                this.ctx.lineTo(wireX, y); 
                this.ctx.strokeStyle = '#000000'; 
                this.ctx.lineWidth = 4;
                this.ctx.stroke();

                this.ctx.strokeStyle = '#000000'; 
                this.ctx.lineWidth = 4;
                
                this.ctx.beginPath();
                this.ctx.moveTo(wireX, y);
                this.ctx.lineTo(wireX, y + 15);
                this.ctx.stroke();
                
                this.ctx.beginPath();
                this.ctx.moveTo(wireX - 18, y + 15);
                this.ctx.lineTo(wireX + 18, y + 15);
                this.ctx.stroke();
                
                this.ctx.beginPath();
                this.ctx.moveTo(wireX - 12, y + 22);
                this.ctx.lineTo(wireX + 12, y + 22);
                this.ctx.stroke();
                
                this.ctx.beginPath();
                this.ctx.moveTo(wireX - 6, y + 29);
                this.ctx.lineTo(wireX + 6, y + 29);
                this.ctx.stroke();

                this.ctx.save();
                this.ctx.font = "40px Arial";
                this.ctx.textAlign = "center";
                this.ctx.textBaseline = "middle";
                this.ctx.translate(x + r + 15, cy + 15);
                this.ctx.rotate(-1.57); 
                this.ctx.fillText("ğŸ‘†", 0, 0);
                this.ctx.restore();

                if (this.state.isGrounded) {
                    let chars = [];
                    let arrow = "";
                    
                    if (this.rod.charge === 1) { 
                        chars = ["é›»","å­","å¾","åœ°","çƒ","æµ","å…¥"];
                        arrow = "â†‘";
                    } else { 
                        chars = ["é›»","å­","å¾","é‡‘","å±¬","çƒ","æµ","å‡º"];
                        arrow = "â†“";
                    }
                    
                    if (chars.length > 0) {
                        this.ctx.fillStyle = "#2c3e50"; 
                        this.ctx.font = "bold 24px 'Microsoft JhengHei', Arial"; 
                        this.ctx.textAlign = "center";
                        this.ctx.textBaseline = "middle";

                        let textX = wireX - 45;
                        let centerY = (y + cy) / 2;
                        let startY = centerY - (chars.length * 28) / 2;
                        
                        for(let i=0; i<chars.length; i++) {
                            this.ctx.fillText(chars[i], textX, startY + i*28);
                        }
                        
                        this.ctx.fillStyle = "#e74c3c"; 
                        this.ctx.font = "bold 40px Arial";
                        this.ctx.fillText(arrow, wireX + 40, centerY);
                    }
                }
            },

            drawConductor: function() {
                const {x, y, r} = this.conductor;
                
                this.ctx.fillStyle = '#5d4037'; 
                let baseW = 80;
                let baseH = 15;
                this.ctx.fillRect(x - baseW/2, this.CONFIG.groundY - baseH, baseW, baseH);

                let standW = 16;
                let standH = (this.CONFIG.groundY - baseH) - (y + r);
                this.ctx.fillStyle = '#95a5a6';
                this.ctx.fillRect(x - standW/2, y + r - 2, standW, standH + 2);
                
                this.ctx.beginPath();
                this.ctx.arc(x, y, r, 0, Math.PI*2);
                let grad = this.ctx.createRadialGradient(x - r*0.3, y - r*0.3, r*0.1, x, y, r);
                grad.addColorStop(0, '#f8f9fa');
                grad.addColorStop(1, '#95a5a6');
                this.ctx.fillStyle = grad;
                this.ctx.fill();

                this.ctx.beginPath();
                this.ctx.arc(x, y, r, 0, Math.PI*2);
                this.ctx.lineWidth = 2;
                this.ctx.strokeStyle = '#bdc3c7';
                this.ctx.stroke();
            },

            drawCharge: function(x, y, color, symbol) {
                const r = this.CONFIG.particleSize * (this.width / 400); 
                this.ctx.beginPath();
                this.ctx.arc(x, y, r, 0, Math.PI*2);
                this.ctx.fillStyle = '#fff';
                this.ctx.fill();
                this.ctx.lineWidth = 2;
                this.ctx.strokeStyle = color;
                this.ctx.stroke();

                this.ctx.fillStyle = color;
                this.ctx.font = `bold ${r*1.2}px Arial`;
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                this.ctx.fillText(symbol, x, y + 1);
            },

            drawRod: function() {
                this.ctx.save();
                this.ctx.translate(this.rod.x, this.rod.y);
                this.ctx.rotate(this.rod.angle); 

                const L = this.rodSize.L;
                const W = this.rodSize.W;
                const chargeColor = this.rod.charge < 0 ? '#3498db' : '#e74c3c';
                const symbol = this.rod.charge < 0 ? '-' : '+';
                
                this.ctx.fillStyle = (this.rod.charge < 0) ? '#34495e' : 'rgba(236, 240, 241, 0.95)';
                this.ctx.beginPath();
                this.ctx.roundRect(-L/2, -W/2, L, W, W/2);
                this.ctx.fill();
                this.ctx.strokeStyle = '#bdc3c7';
                this.ctx.lineWidth = 1;
                this.ctx.stroke();

                const headX = L/2 - W/2;
                const headR = W * 0.8;
                this.ctx.beginPath();
                this.ctx.arc(headX, 0, headR, 0, Math.PI*2);
                this.ctx.fillStyle = '#fff'; 
                this.ctx.fill();
                this.ctx.strokeStyle = chargeColor; 
                this.ctx.lineWidth = 4;
                this.ctx.stroke();

                this.ctx.fillStyle = chargeColor;
                this.ctx.font = 'bold 28px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                this.ctx.fillText(symbol, headX, 2);

                this.ctx.fillStyle = '#2c3e50';
                this.ctx.fillRect(-L/2, -W/2, 40, W); 
                this.ctx.strokeStyle = '#555';
                this.ctx.lineWidth = 2;
                for(let i=0; i<3; i++) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(-L/2 + 10 + i*10, -W/2);
                    this.ctx.lineTo(-L/2 + 10 + i*10, W/2);
                    this.ctx.stroke();
                }

                this.ctx.restore();
            },

            handleMouse: function(e) {
                if (e.type === 'mousedown') this.startDrag(e);
                else if (e.type === 'mousemove') this.drag(e);
                else if (e.type === 'mouseup' || e.type === 'mouseleave') this.endDrag(e);
            },

            handleTouch: function(e) {
                e.preventDefault();
                if (e.type === 'touchstart') this.startDrag(e);
                else if (e.type === 'touchmove') this.drag(e);
                else if (e.type === 'touchend') this.endDrag(e);
            },

            getPos: function(e) {
                const rect = this.canvas.getBoundingClientRect();
                let cx, cy;
                if (e.touches && e.touches.length > 0) {
                    cx = e.touches[0].clientX;
                    cy = e.touches[0].clientY;
                } else if (e.clientX !== undefined) {
                    cx = e.clientX;
                    cy = e.clientY;
                } else {
                    return {x: this.rod.x, y: this.rod.y};
                }
                return { x: cx - rect.left, y: cy - rect.top };
            },

            startDrag: function(e) {
                let p = this.getPos(e);
                let dist = Math.sqrt(Math.pow(p.x - this.rod.x, 2) + Math.pow(p.y - this.rod.y, 2));
                if (dist < 150) {
                    this.rod.dragging = true;
                    this.updateRodPos(p.x, p.y);
                }
            },

            drag: function(e) {
                if (!this.rod.dragging) return;
                let p = this.getPos(e);
                this.updateRodPos(p.x, p.y);
            },

            endDrag: function() {
                this.rod.dragging = false;
            },

            updateRodPos: function(targetX, targetY) {
                let dxRod = this.conductor.x - targetX;
                let dyRod = this.conductor.y - targetY;
                let angle = Math.atan2(dyRod, dxRod);

                let halfL = this.rodSize.L / 2;
                let tipX = targetX + Math.cos(angle) * halfL;
                let tipY = targetY + Math.sin(angle) * halfL;

                // é‚Šç•Œæª¢æŸ¥
                tipX = Math.max(0, Math.min(this.width, tipX));
                tipY = Math.max(0, Math.min(this.height, tipY));

                this.rod.x = tipX - Math.cos(angle) * halfL;
                this.rod.y = tipY - Math.sin(angle) * halfL;

                let finalDx = this.conductor.x - this.rod.x;
                let finalDy = this.conductor.y - this.rod.y;
                let dist = Math.sqrt(finalDx*finalDx + finalDy*finalDy);
                let minSafeDist = halfL + this.conductor.r + this.CONFIG.gap;

                if (dist < minSafeDist) {
                     this.rod.x = this.conductor.x - Math.cos(angle) * minSafeDist;
                     this.rod.y = this.conductor.y - Math.sin(angle) * minSafeDist;
                }
            },

            setRod: function(c) {
                this.rod.charge = c;
                this.reset(); 
                document.getElementById('btnNeg').className = c===-1 ? 'btn-toggle active-neg' : 'btn-toggle';
                document.getElementById('btnPos').className = c===1 ? 'btn-toggle active-pos' : 'btn-toggle';
            },

            loop: function() {
                this.update();
                this.draw();
                requestAnimationFrame(() => this.loop());
            }
        };

        window.onload = function() {
            APP.init();
        };

    </script>
</body>
</html>