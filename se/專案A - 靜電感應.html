<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    
    <title>晟自然輔助系統　靜電感應</title>
    
    <style>
        /* =========================================
           1. 核心架構：App Shell (固定視窗)
           ========================================= */
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100dvh;  /* 鎖定手機實際高度 */
            overflow: hidden; /* 禁止全域捲動 */
            
            display: flex;
            flex-direction: column;
            align-items: center;
            
            background-image: url('page.jpg'); 
            background-size: cover;
            background-position: center;
            background-color: #000;
            font-family: 'Microsoft JhengHei', 'Segoe UI', sans-serif;
            color: #333;
        }

        .app-layout-wrapper {
            width: 100%;
            max-width: 600px; 
            height: 100%;
            display: flex;
            flex-direction: column;
            position: relative;
            background: transparent;
        }

        /* =========================================
           2. 頂部：標題列 (固定)
           ========================================= */
        .main-header {
            flex: 0 0 60px; /* 高度固定 */
            width: 100%;
            background: linear-gradient(90deg, #1a2a6c, #b21f1f, #fdbb2d);
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            z-index: 100;
            display: flex;
            align-items: center;
            padding: 0 15px;
            box-sizing: border-box;
            color: white;
        }

        .logo-area {
            width: 40px;
            height: 40px;
            background-color: white;
            border-radius: 50%;
            margin-right: 15px;
            background-image: url('logo.jpg');
            background-size: cover;
            border: 2px solid #00d2ff;
            flex-shrink: 0; /* 防止被壓縮 */
            cursor: pointer;
            display: block;
        }

        .header-title {
            font-size: 1.0rem;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
            color: white;
            white-space: normal;
            line-height: 1.2;          
            max-height: 2.4em;         
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
            flex: 1;                   
            padding-right: 10px;       
        }

        /* LINE 按鈕 */
        .line-btn {
            margin-left: auto;
            background-color: #06c755; /* 更新為官方綠色 */
            color: white;
            text-decoration: none;
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: bold;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            border: 1px solid rgba(255,255,255,0.5);
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            white-space: nowrap;
        }
        
        .line-btn:active {
            transform: scale(0.95); /* 點擊回饋 */
        }

        /* =========================================
           3. 中間：內容區 (可滾動)
           ========================================= */
        .content-scroll-area {
            flex: 1 1 auto;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            width: 100%;
            padding: 0;
            padding-bottom: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        /* 3-1. 視覺模擬區容器 (預設) */
        .simulation-container {
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            margin-top: 10px;
            /* 針對 Canvas 專案的特別調整：給予明確高度以便繪圖 */
            height: 60vh; 
            min-height: 400px;
            background: rgba(255,255,255,0.1); /* 輕微標示區域 */
        }
        
        canvas { display: block; width: 100%; height: 100%; }
		
		/* =========================================
           4. [標準組件] 通用 UI 卡片規範
           ========================================= */
        .ui-card {
            width: 96% !important;   /* 強制統一寬度 */
            max-width: 96% !important;
            box-sizing: border-box;  /* 內含式邊框，避免撐大 */
            margin-left: auto;
            margin-right: auto;
            margin-top: 15px;
            
            background: rgba(255, 255, 255, 0.95);
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            border: 1px solid rgba(0,0,0,0.05);
            padding: 12px;
        }

        .topic-description {
            text-align: center;
            color: #444;
            font-size: 0.95rem;
            line-height: 1.5;
        }

        /* =========================================
           5. 底部控制塢 (Footer)
           ========================================= */
        .controls-dock {
            flex: 0 0 auto;
            width: 100%;
            background: rgba(255, 255, 255, 0.98);
            box-shadow: 0 -4px 15px rgba(0,0,0,0.1);
            z-index: 100;
            padding: 15px;
            box-sizing: border-box;
            
            padding-bottom: calc(20px + env(safe-area-inset-bottom));
            
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }
        
        /* =========================================
           6. [專案移植] 靜電感應專用組件
           ========================================= */
        
        /* 浮動提示標籤 */
        .instruction-tag {
            position: absolute;
            top: 15px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.95);
            padding: 8px 24px;
            border-radius: 50px;
            font-size: 0.95rem;
            color: #555;
            font-weight: 600;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            pointer-events: none; 
            white-space: nowrap;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(0,0,0,0.05);
            transition: all 0.3s ease;
            z-index: 10;
        }
        .instruction-tag.active {
            color: #c0392b;
            border: 2px solid #e74c3c;
            background: #fff;
            transform: translateX(-50%) scale(1.05);
        }

        /* 膠囊開關 (移植自專案A) */
        .switch-capsule {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            background: #f1f3f5;
            border-radius: 100px;
            box-shadow: inset 0 2px 6px rgba(0,0,0,0.06);
            padding: 5px 15px; 
            gap: 10px;
            width: 100%; /* 填滿 Footer */
            max-width: 320px;
        }

        .btn-toggle {
            width: 44px; height: 44px;
            border: none; border-radius: 50%;
            font-size: 1.5rem; font-weight: 800;
            cursor: pointer;
            background: transparent; color: #bdc3c7;
            display: flex; align-items: center; justify-content: center;
            transition: all 0.2s;
        }
        .btn-toggle:active { transform: scale(0.95); }
        .btn-toggle.active-neg { background: #3498db; color: white; box-shadow: 0 4px 12px rgba(52, 152, 219, 0.4); }
        .btn-toggle.active-pos { background: #e74c3c; color: white; box-shadow: 0 4px 12px rgba(231, 76, 60, 0.4); }
        
        .deck-label { font-size: 1rem; font-weight: 700; color: #666; white-space: nowrap; margin-right: 5px; }
        .divider { width: 1px; height: 24px; background: #cbd5e0; margin: 0 5px; }

    </style>
</head>
<body>

    <div class="app-layout-wrapper">
        
        <header class="main-header">
            <a href="index.html" class="logo-area" title="返回大廳"></a>
            <div class="header-title">晟自然輔助系統<br>靜電感應</div>
            
            <a href="https://line.me/ti/g2/TTCqPpZP6lQqX1z_AUDPNm4977Dvylew3O7oBg" target="_blank" class="line-btn">
                加 LINE 討論
            </a>
        </header>

        <main class="content-scroll-area">
            
            <div class="simulation-container" id="sim-container">
                <div class="instruction-tag" id="infoTag">拖曳帶電棒靠近導體，觀察電子移動狀況</div>
                <canvas id="simCanvas"></canvas>
            </div>
            
            </main>

        <footer class="controls-dock" id="controls-area">
            <div class="switch-capsule">
                <span class="deck-label">帶電棒</span>
                <button class="btn-toggle active-neg" id="btnNeg" onclick="APP.setRod(-1)">－</button>
                <div class="divider"></div>    
                <button class="btn-toggle" id="btnPos" onclick="APP.setRod(1)">＋</button>       
            </div>
		</footer>

    </div>

    <script>
        // --- 靜電感應模擬核心邏輯 (移植版) ---
        const APP = {
            canvas: null,
            ctx: null,
            wrapper: null,
            width: 0,
            height: 0,
            dpr: 1,

            // 場景物件
            conductor: { x: 0, y: 0, r: 0 },
            rod: { x: 0, y: 0, charge: -1, dragging: false, angle: 0 }, 
            particles: [], 
            protons: [],   

            CONFIG: {
                radiusBase: 90,     
                particleSize: 15,   
                k_rod: 150000,      
                k_self: 7000,       
                k_core: 0,          
                damping: 0.6,       
                rodLen: 100,        
                rodW: 34,           
                gap: 50,            
                inductionThreshold: 160
            },

            state: {
                inductionLevel: 0 
            },

            init: function() {
                this.wrapper = document.getElementById('sim-container');
                this.canvas = document.getElementById('simCanvas');
                
                if (!this.wrapper || !this.canvas) {
                    console.error("Initialization failed: Elements not found");
                    return;
                }

                this.ctx = this.canvas.getContext('2d');
                this.dpr = window.devicePixelRatio || 1;

                // 綁定事件
                const bind = (evts, handler) => evts.forEach(e => this.canvas.addEventListener(e, handler, {passive: false}));
                bind(['mousedown', 'mousemove', 'mouseup', 'mouseleave'], e => this.handleMouse(e));
                bind(['touchstart', 'touchmove', 'touchend'], e => this.handleTouch(e));
                
                // 監聽視窗變動
                window.addEventListener('resize', () => this.resize());

                // 初始化尺寸與啟動
                this.resize();
                this.loop();
                console.log("靜電感應模擬啟動完成");
            },

            resize: function() {
                // 讀取容器實際像素大小
                const rect = this.wrapper.getBoundingClientRect();
                this.width = rect.width;
                this.height = rect.height;

                // 設定 Canvas 解析度 (Retina 優化)
                this.canvas.width = this.width * this.dpr;
                this.canvas.height = this.height * this.dpr;
                this.ctx.scale(this.dpr, this.dpr);

                // 1. 導體：置中
                this.conductor.x = this.width / 2;
                this.conductor.y = this.height / 2;
                
                // 2. 縮放比例：根據畫面短邊來決定物件大小
                // 基準值 450px 
                let scale = Math.min(this.width, this.height) / 450;
                
                this.conductor.r = this.CONFIG.radiusBase * scale;
                this.rodSize = {
                    L: this.CONFIG.rodLen * scale,
                    W: this.CONFIG.rodW * scale
                };

                // 重置粒子
                this.initParticles();

                // 若帶電棒尚未有位置(剛開啟)，給予預設位置
                // 如果已經有位置，需按比例調整嗎？簡單起見若超出邊界則重置
                if (this.rod.x === 0 || this.rod.x > this.width || this.rod.y > this.height) {
                    this.rod.x = this.width * 0.85; 
                    this.rod.y = this.height * 0.85;
                }
            },

            initParticles: function() {
                this.particles = [];
                this.protons = [];
                const {x, y, r} = this.conductor;
                
                const offset = r * 0.45;
                const pos = [
                    {x: x-offset, y: y-offset}, {x: x+offset, y: y-offset},
                    {x: x-offset, y: y+offset}, {x: x+offset, y: y+offset}
                ];

                pos.forEach(p => {
                    this.protons.push({x: p.x, y: p.y});
                    this.particles.push({
                        x: p.x + (Math.random()-0.5)*10,
                        y: p.y + (Math.random()-0.5)*10,
                        vx: 0, vy: 0
                    });
                });
            },

            update: function() {
                let dxRod = this.conductor.x - this.rod.x;
                let dyRod = this.conductor.y - this.rod.y;
                this.rod.angle = Math.atan2(dyRod, dxRod); 

                let halfL = this.rodSize.L / 2;
                let tipX = this.rod.x + Math.cos(this.rod.angle) * halfL;
                let tipY = this.rod.y + Math.sin(this.rod.angle) * halfL;

                let distToCenter = Math.sqrt(dxRod*dxRod + dyRod*dyRod);
                let surfaceDist = distToCenter - this.conductor.r - halfL;
                let maxEffectDist = this.CONFIG.inductionThreshold; 
                
                if (surfaceDist < 0) surfaceDist = 0;
                
                if (surfaceDist > maxEffectDist) {
                    this.state.inductionLevel = 0;
                } else {
                    this.state.inductionLevel = 1 - (surfaceDist / maxEffectDist);
                }

                const isInducting = this.state.inductionLevel > 0;
                const infoTag = document.getElementById('infoTag');
                
                if (infoTag) {
                    if (isInducting) {
                        infoTag.innerText = "⚡ 靜電感應：不接觸 使正,負電荷暫時分離";
                        infoTag.classList.add('active');
                    } else {
                        infoTag.innerText = "拖曳帶電棒靠近導體，觀察電子移動狀況";
                        infoTag.classList.remove('active');
                    }
                }

                const pR = this.CONFIG.particleSize;
                const scale = Math.min(this.width, this.height) / 450;

                this.particles.forEach((p, i) => {
                    let fx = 0, fy = 0;

                    let dx = p.x - tipX;
                    let dy = p.y - tipY;
                    let distSq = dx*dx + dy*dy;
                    if (distSq < 100) distSq = 100;
                    let isRepel = (this.rod.charge === -1);
                    
                    let rodF = (this.CONFIG.k_rod * scale) / distSq;
                    let dist = Math.sqrt(distSq);

                    if (!isInducting) rodF = 0;

                    if (isRepel) { fx += (dx / dist) * rodF; fy += (dy / dist) * rodF; }
                    else { fx -= (dx / dist) * rodF; fy -= (dy / dist) * rodF; }

                    this.particles.forEach((other, j) => {
                        if (i === j) return;
                        let odx = p.x - other.x;
                        let ody = p.y - other.y;
                        let od2 = odx*odx + ody*ody;
                        let od = Math.sqrt(od2);
                        if (od < 1) od = 1;
                        let repF = (this.CONFIG.k_self * scale) / (od2);
                        fx += (odx / od) * repF;
                        fy += (ody / od) * repF;
                    });

                    p.vx = (p.vx + fx) * this.CONFIG.damping;
                    p.vy = (p.vy + fy) * this.CONFIG.damping;
                    if (Math.abs(p.vx) < 0.1) p.vx = 0;
                    if (Math.abs(p.vy) < 0.1) p.vy = 0;
                    let nextX = p.x + p.vx;
                    let nextY = p.y + p.vy;

                    let cdx = nextX - this.conductor.x;
                    let cdy = nextY - this.conductor.y;
                    let cDist = Math.sqrt(cdx*cdx + cdy*cdy);
                    let limitR = this.conductor.r - pR - 2;

                    if (cDist > limitR) {
                        let ang = Math.atan2(cdy, cdx);
                        p.x = this.conductor.x + limitR * Math.cos(ang);
                        p.y = this.conductor.y + limitR * Math.sin(ang);
                        p.vx = 0; p.vy = 0;
                    } else {
                        p.x = nextX; p.y = nextY;
                    }

                    this.particles.forEach((other, j) => {
                        if (i === j) return;
                        let dX = p.x - other.x;
                        let dY = p.y - other.y;
                        let d = Math.sqrt(dX*dX + dY*dY);
                        let minD = pR * 2 + 1;
                        if (d < minD && d > 0) {
                            let push = (minD - d) * 0.5;
                            p.x += (dX/d) * push;
                            p.y += (dY/d) * push;
                        }
                    });
                });
            },

            draw: function() {
                this.ctx.clearRect(0, 0, this.width, this.height);
                this.drawConductor(); 
                this.protons.forEach(p => this.drawCharge(p.x, p.y, '#e74c3c', '+'));
                this.particles.forEach(p => this.drawCharge(p.x, p.y, '#3498db', '-'));
                this.drawRod();
            },

            drawConductor: function() {
                const {x, y, r} = this.conductor;
                this.ctx.fillStyle = '#95a5a6';
                this.ctx.fillRect(x - 8, y + r - 2, 16, this.height); 
                
                this.ctx.beginPath();
                this.ctx.arc(x, y, r, 0, Math.PI*2);
                let grad = this.ctx.createRadialGradient(x - r*0.3, y - r*0.3, r*0.1, x, y, r);
                grad.addColorStop(0, '#f8f9fa');
                grad.addColorStop(1, '#95a5a6');
                this.ctx.fillStyle = grad;
                this.ctx.fill();

                if (this.state.inductionLevel > 0) {
                    let opacity = this.state.inductionLevel * 0.3; 
                    let angleToRod = Math.atan2(this.rod.y - y, this.rod.x - x);
                    
                    const colorPos = `rgba(231, 76, 60, ${opacity})`; 
                    const colorNeg = `rgba(52, 152, 219, ${opacity})`; 
                    let nearColor = (this.rod.charge < 0) ? colorPos : colorNeg;
                    let farColor = (this.rod.charge < 0) ? colorNeg : colorPos;
                    
                    this.ctx.save();
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, r, angleToRod - Math.PI/2, angleToRod + Math.PI/2);
                    this.ctx.fillStyle = nearColor;
                    this.ctx.fill();
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, r, angleToRod + Math.PI/2, angleToRod + Math.PI*1.5);
                    this.ctx.fillStyle = farColor;
                    this.ctx.fill();
                    this.ctx.restore();

                    if (this.state.inductionLevel > 0.1) {
                        this.ctx.save();
                        const txtColorPos = '#c0392b';
                        const txtColorNeg = '#2980b9';
                        let nearTxtColor = (this.rod.charge < 0) ? txtColorPos : txtColorNeg;
                        let farTxtColor = (this.rod.charge < 0) ? txtColorNeg : txtColorPos;

                        let nearText = (this.rod.charge < 0) ? "異性電(+)" : "異性電(-)";
                        let farText = (this.rod.charge < 0) ? "同性電(-)" : "同性電(+)";

                        let labelDist = r + 35; 
                        let offsetAngle = Math.PI / 6; 

                        let nx = x + Math.cos(angleToRod - offsetAngle) * labelDist;
                        let ny = y + Math.sin(angleToRod - offsetAngle) * labelDist;
                        let fx = x + Math.cos(angleToRod + Math.PI - offsetAngle) * labelDist;
                        let fy = y + Math.sin(angleToRod + Math.PI - offsetAngle) * labelDist;

                        this.ctx.globalAlpha = Math.min(1, this.state.inductionLevel * 2);
                        this.ctx.font = `bold 15px "Microsoft JhengHei", Arial`;
                        this.ctx.textAlign = 'center';
                        this.ctx.textBaseline = 'middle';
                        this.ctx.shadowColor = "rgba(255, 255, 255, 0.8)";
                        this.ctx.shadowBlur = 4;

                        this.ctx.fillStyle = nearTxtColor;
                        this.ctx.fillText(nearText, nx, ny);
                        
                        this.ctx.fillStyle = farTxtColor;
                        this.ctx.fillText(farText, fx, fy);
                        this.ctx.restore();
                    }
                }

                this.ctx.beginPath();
                this.ctx.arc(x, y, r, 0, Math.PI*2);
                this.ctx.lineWidth = 2;
                this.ctx.strokeStyle = '#bdc3c7';
                this.ctx.stroke();
            },

            drawCharge: function(x, y, color, symbol) {
                const scale = Math.min(this.width, this.height) / 450;
                const r = this.CONFIG.particleSize * scale; 

                this.ctx.beginPath();
                this.ctx.arc(x, y, r, 0, Math.PI*2);
                this.ctx.fillStyle = '#fff';
                this.ctx.fill();
                this.ctx.lineWidth = 2;
                this.ctx.strokeStyle = color;
                this.ctx.stroke();

                this.ctx.fillStyle = color;
                this.ctx.font = `bold ${r*1.2}px Arial`;
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                this.ctx.fillText(symbol, x, y + 1);
            },

            drawRod: function() {
                this.ctx.save();
                this.ctx.translate(this.rod.x, this.rod.y);
                this.ctx.rotate(this.rod.angle); 

                const L = this.rodSize.L;
                const W = this.rodSize.W;
                const chargeColor = this.rod.charge < 0 ? '#3498db' : '#e74c3c';
                const symbol = this.rod.charge < 0 ? '-' : '+';
                
                this.ctx.fillStyle = (this.rod.charge < 0) ? '#34495e' : 'rgba(236, 240, 241, 0.95)';
                this.ctx.beginPath();
                this.ctx.roundRect(-L/2, -W/2, L, W, W/2);
                this.ctx.fill();
                this.ctx.strokeStyle = '#bdc3c7';
                this.ctx.lineWidth = 1;
                this.ctx.stroke();

                const headX = L/2 - W/2;
                const headR = W * 0.8;
                this.ctx.beginPath();
                this.ctx.arc(headX, 0, headR, 0, Math.PI*2);
                this.ctx.fillStyle = '#fff'; 
                this.ctx.fill();
                this.ctx.strokeStyle = chargeColor; 
                this.ctx.lineWidth = 4;
                this.ctx.stroke();

                this.ctx.fillStyle = chargeColor;
                this.ctx.font = 'bold 28px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                this.ctx.fillText(symbol, headX, 2);

                this.ctx.fillStyle = '#2c3e50';
                this.ctx.fillRect(-L/2, -W/2, 40, W); 
                this.ctx.strokeStyle = '#555';
                this.ctx.lineWidth = 2;
                for(let i=0; i<3; i++) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(-L/2 + 10 + i*10, -W/2);
                    this.ctx.lineTo(-L/2 + 10 + i*10, W/2);
                    this.ctx.stroke();
                }

                this.ctx.restore();
            },

            getPos: function(e) {
                const rect = this.canvas.getBoundingClientRect();
                let cx, cy;
                if (e.touches && e.touches.length > 0) {
                    cx = e.touches[0].clientX;
                    cy = e.touches[0].clientY;
                } else if (e.clientX !== undefined) {
                    cx = e.clientX;
                    cy = e.clientY;
                } else {
                    return {x: this.rod.x, y: this.rod.y};
                }

                let screenX = cx - rect.left;
                let screenY = cy - rect.top;
                return { x: screenX, y: screenY };
            },

            handleMouse: function(e) {
                if (e.type === 'mousedown') this.startDrag(e);
                else if (e.type === 'mousemove') this.drag(e);
                else if (e.type === 'mouseup' || e.type === 'mouseleave') this.endDrag(e);
            },

            handleTouch: function(e) {
                e.preventDefault();
                if (e.type === 'touchstart') this.startDrag(e);
                else if (e.type === 'touchmove') this.drag(e);
                else if (e.type === 'touchend') this.endDrag(e);
            },

            startDrag: function(e) {
                let p = this.getPos(e);
                let dist = Math.sqrt(Math.pow(p.x - this.rod.x, 2) + Math.pow(p.y - this.rod.y, 2));
                if (dist < 150) {
                    this.rod.dragging = true;
                    this.updateRodPos(p.x, p.y);
                }
            },

            drag: function(e) {
                if (!this.rod.dragging) return;
                let p = this.getPos(e);
                this.updateRodPos(p.x, p.y);
            },

            endDrag: function() {
                this.rod.dragging = false;
            },

            updateRodPos: function(targetX, targetY) {
                let dxRod = this.conductor.x - targetX;
                let dyRod = this.conductor.y - targetY;
                let angle = Math.atan2(dyRod, dxRod);

                let halfL = this.rodSize.L / 2;
                let tipX = targetX + Math.cos(angle) * halfL;
                let tipY = targetY + Math.sin(angle) * halfL;

                // 邊界檢查
                tipX = Math.max(0, Math.min(this.width, tipX));
                tipY = Math.max(0, Math.min(this.height, tipY));

                this.rod.x = tipX - Math.cos(angle) * halfL;
                this.rod.y = tipY - Math.sin(angle) * halfL;

                let finalDx = this.conductor.x - this.rod.x;
                let finalDy = this.conductor.y - this.rod.y;
                let dist = Math.sqrt(finalDx*finalDx + finalDy*finalDy);
                let minSafeDist = halfL + this.conductor.r + this.CONFIG.gap;

                if (dist < minSafeDist) {
                     this.rod.x = this.conductor.x - Math.cos(angle) * minSafeDist;
                     this.rod.y = this.conductor.y - Math.sin(angle) * minSafeDist;
                }
            },

            setRod: function(c) {
                this.rod.charge = c;
                document.getElementById('btnNeg').className = c===-1 ? 'btn-toggle active-neg' : 'btn-toggle';
                document.getElementById('btnPos').className = c===1 ? 'btn-toggle active-pos' : 'btn-toggle';
            },

            loop: function() {
                this.update();
                this.draw();
                requestAnimationFrame(() => this.loop());
            }
        };

        window.onload = function() {
            APP.init();
        };

    </script>
</body>
</html>