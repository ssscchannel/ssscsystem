<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>æ™Ÿè‡ªç„¶è¼”åŠ©ç³»çµ±ã€€éœé›»æ„Ÿæ‡‰</title>
    
    <style>
        /* =========================================
           1. å…¨å±€è¨­å®šï¼šå¼·åˆ¶ä¸€é å¼ (No Scroll)
           ========================================= */
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            /* é›™é‡ä¿éšªçš„é«˜åº¦è¨­å®š */
            height: 100vh;   /* èˆŠç€è¦½å™¨ç›¸å®¹ */
            height: 100dvh;  /* é—œéµï¼šè‡ªå‹•æ‰£é™¤æ‰‹æ©Ÿå·¥å…·åˆ—é«˜åº¦ */
            overflow: hidden; /* ç¦æ­¢ä»»ä½•æ²å‹• */
            
            /* å½ˆæ€§ä½ˆå±€ï¼šå‚ç›´æ’åˆ— */
            display: flex;
            flex-direction: column;
            align-items: center; /* æ°´å¹³ç½®ä¸­ */
            
            /* èƒŒæ™¯è¨­å®š (å¯ä¾å°ˆæ¡ˆæ›¿æ›) */
            background-image: url('page.jpg'); 
            background-size: cover;
            background-position: center;
            background-color: #000; /* åœ–ç‰‡è¼‰å…¥å‰çš„é è¨­åº•è‰² */
            font-family: 'Microsoft JhengHei', 'Segoe UI', sans-serif;
        }

        /* =========================================
           2. æ¨™æº–æ¨™é¡Œå€ (Header Container)
           ========================================= */
        .header-container {
            flex-shrink: 0; /* ç¦æ­¢è¢«å£“ç¸® */
            
            /* å¯¬åº¦èˆ‡å°é½Šè¨­å®š */
            width: 97%;
            box-sizing: border-box; /* ç¢ºä¿ padding ä¸æœƒæ’å¤§å¯¬åº¦ */
            max-width: 800px;       /* é™åˆ¶æœ€å¤§å¯¬åº¦ï¼Œé¿å…åœ¨é›»è…¦ä¸Šå¤ªå¯¬ */
            
            /* å…§éƒ¨æ’ç‰ˆï¼šå·¦å³æ¨é–‹ */
            display: flex;
            justify-content: space-between; 
            align-items: center;
            
            /* è¦–è¦ºé¢¨æ ¼ (çµ±ä¸€è¦ç¯„) */
            padding: 8px 15px;
            margin-top: 5px;   /* é ‚éƒ¨å¾®ç•™ç™½ */
            margin-bottom: 8px; /* èˆ‡ä¸‹æ–¹æ¨¡æ“¬å€çš„å‘¼å¸è·é›¢ */
            
            background: rgba(255, 255, 255, 0.9); /* é«˜æ¸…æ™°åº¦åŠé€æ˜ç™½ */
            backdrop-filter: blur(5px);           /* æ¯›ç»ç’ƒç‰¹æ•ˆ */
            border-radius: 12px;                  /* åœ“æ»‘è§’ */
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.15); /* ç«‹é«”æµ®å‹•é™°å½± */
            z-index: 1000;
        }

        /* æ¨™é¡Œæ–‡å­— */
        .header-container h1 {
            margin: 0;
            font-size: 1.1rem; /* æ‰‹æ©Ÿæœ€ä½³é–±è®€å¤§å° */
            color: #333;
            line-height: 1.3;
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 10px;
            white-space: nowrap; /* å¼·åˆ¶å–®è¡Œï¼Œä¸æ›è¡Œ */
        }

        /* Logo åœ–ç‰‡ */
        .title-logo {
            height: 36px; /* å›ºå®šé«˜åº¦ */
            width: auto;
            border-radius: 4px;
        }

        /* ç²¾ç·»åŒ–çš„ LINE æŒ‰éˆ• (è† å›Šç‹€) */
        .header-btn {
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 6px 12px;
            background: #06c755; /* LINE çš„å®˜æ–¹ç¶ è‰² */
            color: white;
            font-size: 0.9rem;
            font-weight: bold;
            border-radius: 20px; /* åœ“è§’è† å›Š */
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            transition: transform 0.1s, background 0.2s;
            white-space: nowrap; /* ç¦æ­¢æ–‡å­—æ›è¡Œ */
        }
		
		.header-btn:active {
            transform: scale(0.95);
        }

        .header-btn span {
            margin-right: 4px; /* åœ–ç¤ºèˆ‡æ–‡å­—è·é›¢ */
        }

        /* =========================================
           3. ä¸­é–“æ¨¡æ“¬å€ (Main Simulation) - è‡ªå‹•å¡«æ»¿
           ========================================= */
        #sim-container {
            /* æ ¸å¿ƒé—œéµï¼šflex: 1 è®“å®ƒè‡ªå‹•ä½”æ“šå‰©é¤˜æ‰€æœ‰ç©ºé–“ */
            flex: 1; 
            width: 100%;
            position: relative;
            overflow: hidden;
        }

        canvas { display: block; width: 100%; height: 100%; }

        /* æµ®å‹•æç¤ºæ¨™ç±¤ (ç¶­æŒåŸè¨­è¨ˆ) */
        .instruction-tag {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.95);
            padding: 8px 24px;
            border-radius: 50px;
            font-size: 0.95rem;
            color: #555;
            font-weight: 600;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            pointer-events: none; 
            white-space: nowrap;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(0,0,0,0.05);
            transition: all 0.3s ease;
            z-index: 10;
        }
        .instruction-tag.active {
            color: #c0392b;
            border: 2px solid #e74c3c;
            background: #fff;
            transform: translateX(-50%) scale(1.05);
        }

        /* =========================================
           4. åº•éƒ¨æ§åˆ¶å€ (Footer Controls) - å·¦å³æ»¿ç‰ˆ
           ========================================= */
        .controls {
            flex: 0 0 auto; /* å›ºå®šé«˜åº¦ï¼Œä¸è¢«å£“ç¸® */
            width: 100%;
            box-sizing: border-box;
            
            /* è¦–è¦ºé¢¨æ ¼ */
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(5px);
            border-top: 1px solid rgba(0,0,0,0.1);
            
            padding: 10px 15px;
            /* é¿è®“ iPhone åº•éƒ¨æ©«æ¢ (Safe Area) */
            padding-bottom: calc(10px + env(safe-area-inset-bottom, 0px));
            
            display: flex;
            justify-content: space-between; /* é—œéµï¼šå·¦å³æ¨é–‹ */
            align-items: center;
            z-index: 1000;
        }

        /* å·¦å´å®¹å™¨ï¼šæ”¾åŸæœ¬çš„è† å›Šé–‹é—œ */
        .controls-left {
            display: flex;
            align-items: center;
        }

        /* å³å´å®¹å™¨ï¼šæ”¾è¿”å›æŒ‰éˆ• */
        .controls-right {
            display: flex;
            align-items: center;
        }

        /* --- åŸæœ‰æŒ‰éˆ•æ¨£å¼ä¿ç•™ --- */
        .switch-capsule {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            background: #f1f3f5;
            border-radius: 100px;
            box-shadow: inset 0 2px 6px rgba(0,0,0,0.06);
            padding: 5px 15px; 
            gap: 10px;
        }

        .btn-toggle {
            width: 44px; height: 44px;
            border: none; border-radius: 50%;
            font-size: 1.5rem; font-weight: 800;
            cursor: pointer;
            background: transparent; color: #bdc3c7;
            display: flex; align-items: center; justify-content: center;
            transition: all 0.2s;
        }
        .btn-toggle:active { transform: scale(0.95); }
        .btn-toggle.active-neg { background: #3498db; color: white; box-shadow: 0 4px 12px rgba(52, 152, 219, 0.4); }
        .btn-toggle.active-pos { background: #e74c3c; color: white; box-shadow: 0 4px 12px rgba(231, 76, 60, 0.4); }
        
        .deck-label { font-size: 0.9rem; font-weight: 700; color: #666; white-space: nowrap; margin-right: 5px; }
        .divider { width: 1px; height: 24px; background: #cbd5e0; margin: 0 5px; }

        /* --- æ–°å¢ï¼šå³å´è¿”å›æŒ‰éˆ• --- */
        .btn-return {
            width: 44px; height: 44px;
            border-radius: 50%;
            background: #fff;
            color: #555;
            display: flex; align-items: center; justify-content: center;
            text-decoration: none;
            font-size: 1.4rem;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            border: 1px solid rgba(0,0,0,0.05);
            transition: all 0.2s;
        }
        .btn-return:active { transform: scale(0.9); background: #f0f0f0; }

        /* RWD: æ‰‹æ©Ÿç›´å¼æ™‚ï¼Œæ¨™é¡Œéé•·è‡ªå‹•æ›è¡Œ */
        .mobile-break { display: none; }
        
        @media (max-width: 600px) {
            .mobile-break { display: block; height: 0; }
            .header-container h1 { font-size: 1rem; }
            .header-btn { padding: 5px 10px; font-size: 0.85rem; }
            .header-btn span { display: none; } /* æ‰‹æ©Ÿç‰ˆå¤ªçª„æ™‚ï¼Œéš±è—æ‰‹æŒ‡åœ–ç¤º */
			.instruction-bar {
    			font-size: 0.8rem; /* æ‰‹æ©Ÿå­—é«”ç¸®å° */
				padding: 5px 15px;
				width: 90%; /* æ‰‹æ©Ÿä¸Šå¯¬åº¦ç¨å¾®æ”¾å¯¬ */
				margin-top: 5px; /* æ‰‹æ©Ÿç‰ˆä¸ä½¿ç”¨è² é‚Šè·ï¼Œé¿å…å¤ªæ“æ“  */
				margin-bottom: 10px;
				flex-direction: row; /* ä¿æŒæ°´å¹³æ’åˆ— */
				flex-wrap: nowrap; /* ç›¡é‡ä¸æ›è¡Œï¼Œè‹¥å­—å¤ªå¤šæœƒè‡ªå‹•ç¸®å° */
				}
        }
		
    </style>
</head>
<body>

    <div class="header-container">
        <h1>
            <img src="logo.jpg" alt="Logo" class="title-logo" onerror="this.style.display='none'">
            <div>
                æ™Ÿè‡ªç„¶è¼”åŠ©ç³»çµ±ã€€éœé›»æ„Ÿæ‡‰
            </div>
        </h1>
        <div class="nav-buttons">
            <a href="https://line.me/ti/g2/TTCqPpZP6lQqX1z_AUDPNm4977Dvylew3O7oBg" target="_blank" class="header-btn">
                <span>ğŸ‘‰</span>åŠ  LINE æå•
            </a>       
        </div>
    </div>

    <div id="sim-container">
        <div class="instruction-tag" id="infoTag">æ‹–æ›³å¸¶é›»æ£’é è¿‘å°é«”ï¼Œè§€å¯Ÿé›»å­ç§»å‹•ç‹€æ³</div>
        <canvas id="simCanvas"></canvas>
    </div>

    <div class="controls">
        <div class="controls-left">
            <div class="switch-capsule">
                <span class="deck-label">å¸¶é›»æ£’</span>
                <button class="btn-toggle active-neg" id="btnNeg" onclick="APP.setRod(-1)">ï¼</button>
                <div class="divider"></div>    
                <button class="btn-toggle" id="btnPos" onclick="APP.setRod(1)">ï¼‹</button>       
            </div>
        </div>

        <div class="controls-right">
            <a href="index.html" class="btn-return" title="è¿”å›é¦–é ">â†©</a>
        </div>
    </div>

    <script>
        // --- æ ¸å¿ƒé‚è¼¯ï¼šå–è‡ªã€Œå°ˆæ¡ˆA - éœé›»æ„Ÿæ‡‰.htmlã€ä¸¦ä¿®æ­£ Resize é©é… ---
        const APP = {
            canvas: null,
            ctx: null,
            wrapper: null,
            width: 0,
            height: 0,
            dpr: 1,

            // å ´æ™¯ç‰©ä»¶ (è³‡æ–™çµæ§‹ç¶­æŒä¸è®Š)
            conductor: { x: 0, y: 0, r: 0 },
            rod: { x: 0, y: 0, charge: -1, dragging: false, angle: 0 }, 
            particles: [], 
            protons: [],   

            CONFIG: {
                radiusBase: 90,     
                particleSize: 15,   
                k_rod: 150000,      
                k_self: 7000,       
                k_core: 0,          
                damping: 0.6,       
                rodLen: 100,        
                rodW: 34,           
                gap: 50,            
                inductionThreshold: 160
            },

            state: {
                inductionLevel: 0 
            },

            init: function() {
                this.wrapper = document.getElementById('sim-container');
                this.canvas = document.getElementById('simCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.dpr = window.devicePixelRatio || 1;

                // ç¶å®šäº‹ä»¶
                const bind = (evts, handler) => evts.forEach(e => this.canvas.addEventListener(e, handler, {passive: false}));
                bind(['mousedown', 'mousemove', 'mouseup', 'mouseleave'], e => this.handleMouse(e));
                bind(['touchstart', 'touchmove', 'touchend'], e => this.handleTouch(e));
                
                // ç›£è½è¦–çª—è®Šå‹• (é‡è¦ï¼šç¢ºä¿ç¿»è½‰è¢å¹•æ™‚ç•«å¸ƒæœƒé‡ç¹ª)
                window.addEventListener('resize', () => this.resize());

                // åˆå§‹åŒ–å°ºå¯¸èˆ‡å•Ÿå‹•
                this.resize();
                this.loop();
            },

            // --- é—œéµä¿®æ­£ï¼šä¸å†é–å®š 500x450ï¼Œè€Œæ˜¯è®€å– flex å»¶å±•å¾Œçš„å¯¦éš›å¤§å° ---
            resize: function() {
                // è®€å–å®¹å™¨å¯¦éš›åƒç´ å¤§å°
                const rect = this.wrapper.getBoundingClientRect();
                this.width = rect.width;
                this.height = rect.height;

                // è¨­å®š Canvas è§£æåº¦ (Retina å„ªåŒ–)
                this.canvas.width = this.width * this.dpr;
                this.canvas.height = this.height * this.dpr;
                this.ctx.scale(this.dpr, this.dpr);

                // 1. å°é«”ï¼šæ°¸é ç½®ä¸­
                this.conductor.x = this.width / 2;
                this.conductor.y = this.height / 2;
                
                // 2. ç¸®æ”¾æ¯”ä¾‹ï¼šæ ¹æ“šç•«é¢çŸ­é‚Šä¾†æ±ºå®šç‰©ä»¶å¤§å° (ç¢ºä¿æ‰‹æ©Ÿä¸Šä¸æœƒå¤ªå¤§æˆ–å¤ªå°)
                // åŸºæº–å€¼ 450px æ˜¯åŸæœ¬è¨­è¨ˆçš„é«˜åº¦
                let scale = Math.min(this.width, this.height) / 450;
                
                this.conductor.r = this.CONFIG.radiusBase * scale;
                this.rodSize = {
                    L: this.CONFIG.rodLen * scale,
                    W: this.CONFIG.rodW * scale
                };

                // é‡ç½®ç²’å­ (å› ç‚ºå°é«”ä½ç½®è®Šäº†)
                this.initParticles();

                // è‹¥å¸¶é›»æ£’å°šæœªæœ‰ä½ç½®(å‰›é–‹å•Ÿ)ï¼Œçµ¦äºˆé è¨­ä½ç½®
                if (this.rod.x === 0) {
                    this.rod.x = this.width * 0.85; 
                    this.rod.y = this.height * 0.85;
                }
            },

            initParticles: function() {
                this.particles = [];
                this.protons = [];
                const {x, y, r} = this.conductor;
                
                const offset = r * 0.45;
                const pos = [
                    {x: x-offset, y: y-offset}, {x: x+offset, y: y-offset},
                    {x: x-offset, y: y+offset}, {x: x+offset, y: y+offset}
                ];

                pos.forEach(p => {
                    this.protons.push({x: p.x, y: p.y});
                    this.particles.push({
                        x: p.x + (Math.random()-0.5)*10,
                        y: p.y + (Math.random()-0.5)*10,
                        vx: 0, vy: 0
                    });
                });
            },

            update: function() {
                let dxRod = this.conductor.x - this.rod.x;
                let dyRod = this.conductor.y - this.rod.y;
                this.rod.angle = Math.atan2(dyRod, dxRod); 

                let halfL = this.rodSize.L / 2;
                let tipX = this.rod.x + Math.cos(this.rod.angle) * halfL;
                let tipY = this.rod.y + Math.sin(this.rod.angle) * halfL;

                let distToCenter = Math.sqrt(dxRod*dxRod + dyRod*dyRod);
                let surfaceDist = distToCenter - this.conductor.r - halfL;
                let maxEffectDist = this.CONFIG.inductionThreshold; // é€™è£¡å¯è€ƒæ…®ä¹˜ä¸Š scaleï¼Œä½†ç›®å‰ç¶­æŒåŸç‰©ç†åƒæ•¸è¼ƒç©©å®š
                
                if (surfaceDist < 0) surfaceDist = 0;
                
                if (surfaceDist > maxEffectDist) {
                    this.state.inductionLevel = 0;
                } else {
                    this.state.inductionLevel = 1 - (surfaceDist / maxEffectDist);
                }

                const isInducting = this.state.inductionLevel > 0;
                const infoTag = document.getElementById('infoTag');
                
                if (isInducting) {
                    infoTag.innerText = "âš¡ éœé›»æ„Ÿæ‡‰ï¼šä¸æ¥è§¸ ä½¿æ­£,è² é›»è·æš«æ™‚åˆ†é›¢";
                    infoTag.classList.add('active');
                } else {
                    infoTag.innerText = "æ‹–æ›³å¸¶é›»æ£’é è¿‘å°é«”ï¼Œè§€å¯Ÿé›»å­ç§»å‹•ç‹€æ³";
                    infoTag.classList.remove('active');
                }

                const pR = this.CONFIG.particleSize;
                // ç‰©ç†åŠ›è¨ˆç®—ä¹Ÿéœ€è¦ä¾ç…§ç¸®æ”¾æ¯”ä¾‹èª¿æ•´ï¼Œæ‰ä¸æœƒåœ¨æ‰‹æ©Ÿä¸Šå¸åŠ›éå¼·
                const scale = Math.min(this.width, this.height) / 450;

                this.particles.forEach((p, i) => {
                    let fx = 0, fy = 0;

                    let dx = p.x - tipX;
                    let dy = p.y - tipY;
                    let distSq = dx*dx + dy*dy;
                    if (distSq < 100) distSq = 100;
                    let isRepel = (this.rod.charge === -1);
                    // ä¿®æ­£ï¼šä¾ç…§ scale èª¿æ•´é›»åŠ›å¸¸æ•¸
                    let rodF = (this.CONFIG.k_rod * scale) / distSq;
                    let dist = Math.sqrt(distSq);

                    if (!isInducting) rodF = 0;

                    if (isRepel) { fx += (dx / dist) * rodF; fy += (dy / dist) * rodF; }
                    else { fx -= (dx / dist) * rodF; fy -= (dy / dist) * rodF; }

                    this.particles.forEach((other, j) => {
                        if (i === j) return;
                        let odx = p.x - other.x;
                        let ody = p.y - other.y;
                        let od2 = odx*odx + ody*ody;
                        let od = Math.sqrt(od2);
                        if (od < 1) od = 1;
                        let repF = (this.CONFIG.k_self * scale) / (od2);
                        fx += (odx / od) * repF;
                        fy += (ody / od) * repF;
                    });

                    p.vx = (p.vx + fx) * this.CONFIG.damping;
                    p.vy = (p.vy + fy) * this.CONFIG.damping;
                    if (Math.abs(p.vx) < 0.1) p.vx = 0;
                    if (Math.abs(p.vy) < 0.1) p.vy = 0;
                    let nextX = p.x + p.vx;
                    let nextY = p.y + p.vy;

                    let cdx = nextX - this.conductor.x;
                    let cdy = nextY - this.conductor.y;
                    let cDist = Math.sqrt(cdx*cdx + cdy*cdy);
                    let limitR = this.conductor.r - pR - 2;

                    if (cDist > limitR) {
                        let ang = Math.atan2(cdy, cdx);
                        p.x = this.conductor.x + limitR * Math.cos(ang);
                        p.y = this.conductor.y + limitR * Math.sin(ang);
                        p.vx = 0; p.vy = 0;
                    } else {
                        p.x = nextX; p.y = nextY;
                    }

                    this.particles.forEach((other, j) => {
                        if (i === j) return;
                        let dX = p.x - other.x;
                        let dY = p.y - other.y;
                        let d = Math.sqrt(dX*dX + dY*dY);
                        let minD = pR * 2 + 1;
                        if (d < minD && d > 0) {
                            let push = (minD - d) * 0.5;
                            p.x += (dX/d) * push;
                            p.y += (dY/d) * push;
                        }
                    });
                });
            },

            draw: function() {
                this.ctx.clearRect(0, 0, this.width, this.height);
                this.drawConductor(); 
                this.protons.forEach(p => this.drawCharge(p.x, p.y, '#e74c3c', '+'));
                this.particles.forEach(p => this.drawCharge(p.x, p.y, '#3498db', '-'));
                this.drawRod();
            },

            drawConductor: function() {
                const {x, y, r} = this.conductor;
                this.ctx.fillStyle = '#95a5a6';
                this.ctx.fillRect(x - 8, y + r - 2, 16, this.height); // æ”¯æ¶å‘ä¸‹å»¶ä¼¸åˆ°åº•
                
                this.ctx.beginPath();
                this.ctx.arc(x, y, r, 0, Math.PI*2);
                let grad = this.ctx.createRadialGradient(x - r*0.3, y - r*0.3, r*0.1, x, y, r);
                grad.addColorStop(0, '#f8f9fa');
                grad.addColorStop(1, '#95a5a6');
                this.ctx.fillStyle = grad;
                this.ctx.fill();

                if (this.state.inductionLevel > 0) {
                    let opacity = this.state.inductionLevel * 0.3; 
                    let angleToRod = Math.atan2(this.rod.y - y, this.rod.x - x);
                    
                    const colorPos = `rgba(231, 76, 60, ${opacity})`; 
                    const colorNeg = `rgba(52, 152, 219, ${opacity})`; 
                    let nearColor = (this.rod.charge < 0) ? colorPos : colorNeg;
                    let farColor = (this.rod.charge < 0) ? colorNeg : colorPos;
                    
                    this.ctx.save();
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, r, angleToRod - Math.PI/2, angleToRod + Math.PI/2);
                    this.ctx.fillStyle = nearColor;
                    this.ctx.fill();
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, r, angleToRod + Math.PI/2, angleToRod + Math.PI*1.5);
                    this.ctx.fillStyle = farColor;
                    this.ctx.fill();
                    this.ctx.restore();

                    if (this.state.inductionLevel > 0.1) {
                        this.ctx.save();
                        const txtColorPos = '#c0392b';
                        const txtColorNeg = '#2980b9';
                        let nearTxtColor = (this.rod.charge < 0) ? txtColorPos : txtColorNeg;
                        let farTxtColor = (this.rod.charge < 0) ? txtColorNeg : txtColorPos;

                        let nearText = (this.rod.charge < 0) ? "ç•°æ€§é›»(+)" : "ç•°æ€§é›»(-)";
                        let farText = (this.rod.charge < 0) ? "åŒæ€§é›»(-)" : "åŒæ€§é›»(+)";

                        let labelDist = r + 35; 
                        let offsetAngle = Math.PI / 6; 

                        let nx = x + Math.cos(angleToRod - offsetAngle) * labelDist;
                        let ny = y + Math.sin(angleToRod - offsetAngle) * labelDist;
                        let fx = x + Math.cos(angleToRod + Math.PI - offsetAngle) * labelDist;
                        let fy = y + Math.sin(angleToRod + Math.PI - offsetAngle) * labelDist;

                        this.ctx.globalAlpha = Math.min(1, this.state.inductionLevel * 2);
                        this.ctx.font = `bold 15px "Microsoft JhengHei", Arial`;
                        this.ctx.textAlign = 'center';
                        this.ctx.textBaseline = 'middle';
                        this.ctx.shadowColor = "rgba(255, 255, 255, 0.8)";
                        this.ctx.shadowBlur = 4;

                        this.ctx.fillStyle = nearTxtColor;
                        this.ctx.fillText(nearText, nx, ny);
                        
                        this.ctx.fillStyle = farTxtColor;
                        this.ctx.fillText(farText, fx, fy);
                        this.ctx.restore();
                    }
                }

                this.ctx.beginPath();
                this.ctx.arc(x, y, r, 0, Math.PI*2);
                this.ctx.lineWidth = 2;
                this.ctx.strokeStyle = '#bdc3c7';
                this.ctx.stroke();
            },

            drawCharge: function(x, y, color, symbol) {
                // ç²’å­å¤§å°éš¨è¢å¹•æ¯”ä¾‹ç¸®æ”¾
                const scale = Math.min(this.width, this.height) / 450;
                const r = this.CONFIG.particleSize * scale; 

                this.ctx.beginPath();
                this.ctx.arc(x, y, r, 0, Math.PI*2);
                this.ctx.fillStyle = '#fff';
                this.ctx.fill();
                this.ctx.lineWidth = 2;
                this.ctx.strokeStyle = color;
                this.ctx.stroke();

                this.ctx.fillStyle = color;
                this.ctx.font = `bold ${r*1.2}px Arial`;
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                this.ctx.fillText(symbol, x, y + 1);
            },

            drawRod: function() {
                this.ctx.save();
                this.ctx.translate(this.rod.x, this.rod.y);
                this.ctx.rotate(this.rod.angle); 

                const L = this.rodSize.L;
                const W = this.rodSize.W;
                const chargeColor = this.rod.charge < 0 ? '#3498db' : '#e74c3c';
                const symbol = this.rod.charge < 0 ? '-' : '+';
                
                this.ctx.fillStyle = (this.rod.charge < 0) ? '#34495e' : 'rgba(236, 240, 241, 0.95)';
                this.ctx.beginPath();
                this.ctx.roundRect(-L/2, -W/2, L, W, W/2);
                this.ctx.fill();
                this.ctx.strokeStyle = '#bdc3c7';
                this.ctx.lineWidth = 1;
                this.ctx.stroke();

                const headX = L/2 - W/2;
                const headR = W * 0.8;
                this.ctx.beginPath();
                this.ctx.arc(headX, 0, headR, 0, Math.PI*2);
                this.ctx.fillStyle = '#fff'; 
                this.ctx.fill();
                this.ctx.strokeStyle = chargeColor; 
                this.ctx.lineWidth = 4;
                this.ctx.stroke();

                this.ctx.fillStyle = chargeColor;
                this.ctx.font = 'bold 28px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                this.ctx.fillText(symbol, headX, 2);

                this.ctx.fillStyle = '#2c3e50';
                this.ctx.fillRect(-L/2, -W/2, 40, W); 
                this.ctx.strokeStyle = '#555';
                this.ctx.lineWidth = 2;
                for(let i=0; i<3; i++) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(-L/2 + 10 + i*10, -W/2);
                    this.ctx.lineTo(-L/2 + 10 + i*10, W/2);
                    this.ctx.stroke();
                }

                this.ctx.restore();
            },

            getPos: function(e) {
                const rect = this.canvas.getBoundingClientRect();
                let cx, cy;
                if (e.touches && e.touches.length > 0) {
                    cx = e.touches[0].clientX;
                    cy = e.touches[0].clientY;
                } else if (e.clientX !== undefined) {
                    cx = e.clientX;
                    cy = e.clientY;
                } else {
                    return {x: this.rod.x, y: this.rod.y};
                }

                // ç›´æ¥å›å‚³ç›¸å°æ–¼ Canvas çš„ä½ç½® (å› ç‚ºç¾åœ¨ Canvas æ˜¯ 1:1 å°æ‡‰è¢å¹•åƒç´ )
                let screenX = cx - rect.left;
                let screenY = cy - rect.top;
                return { x: screenX, y: screenY };
            },

            handleMouse: function(e) {
                if (e.type === 'mousedown') this.startDrag(e);
                else if (e.type === 'mousemove') this.drag(e);
                else if (e.type === 'mouseup' || e.type === 'mouseleave') this.endDrag(e);
            },

            handleTouch: function(e) {
                e.preventDefault();
                if (e.type === 'touchstart') this.startDrag(e);
                else if (e.type === 'touchmove') this.drag(e);
                else if (e.type === 'touchend') this.endDrag(e);
            },

            startDrag: function(e) {
                let p = this.getPos(e);
                let dist = Math.sqrt(Math.pow(p.x - this.rod.x, 2) + Math.pow(p.y - this.rod.y, 2));
                if (dist < 150) {
                    this.rod.dragging = true;
                    this.updateRodPos(p.x, p.y);
                }
            },

            drag: function(e) {
                if (!this.rod.dragging) return;
                let p = this.getPos(e);
                this.updateRodPos(p.x, p.y);
            },

            endDrag: function() {
                this.rod.dragging = false;
            },

            updateRodPos: function(targetX, targetY) {
                let dxRod = this.conductor.x - targetX;
                let dyRod = this.conductor.y - targetY;
                let angle = Math.atan2(dyRod, dxRod);

                let halfL = this.rodSize.L / 2;
                let tipX = targetX + Math.cos(angle) * halfL;
                let tipY = targetY + Math.sin(angle) * halfL;

                // é‚Šç•Œæª¢æŸ¥ (ä½¿ç”¨å‹•æ…‹å¯¬é«˜)
                tipX = Math.max(0, Math.min(this.width, tipX));
                tipY = Math.max(0, Math.min(this.height, tipY));

                this.rod.x = tipX - Math.cos(angle) * halfL;
                this.rod.y = tipY - Math.sin(angle) * halfL;

                let finalDx = this.conductor.x - this.rod.x;
                let finalDy = this.conductor.y - this.rod.y;
                let dist = Math.sqrt(finalDx*finalDx + finalDy*finalDy);
                let minSafeDist = halfL + this.conductor.r + this.CONFIG.gap;

                if (dist < minSafeDist) {
                     this.rod.x = this.conductor.x - Math.cos(angle) * minSafeDist;
                     this.rod.y = this.conductor.y - Math.sin(angle) * minSafeDist;
                }
            },

            setRod: function(c) {
                this.rod.charge = c;
                document.getElementById('btnNeg').className = c===-1 ? 'btn-toggle active-neg' : 'btn-toggle';
                document.getElementById('btnPos').className = c===1 ? 'btn-toggle active-pos' : 'btn-toggle';
            },

            loop: function() {
                this.update();
                this.draw();
                requestAnimationFrame(() => this.loop());
            }
        };

        // å•Ÿå‹•
        window.onload = function() {
            APP.init();
        };

    </script>
</body>
</html>