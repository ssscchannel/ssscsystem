<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    
    <title>æ™Ÿè‡ªç„¶è¼”åŠ©ç³»çµ±ã€€æ„Ÿæ‡‰èµ·é›»</title>
    
    <style>
        /* =========================================
           1. æ ¸å¿ƒæ¶æ§‹ï¼šApp Shell (å›ºå®šè¦–çª—) - Template
           ========================================= */
        :root {
            --ground-color: #27ae60; /* å°ˆæ¡ˆB ç‰¹æœ‰è®Šæ•¸ */
        }

        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100dvh;  
            overflow: hidden; 
            
            display: flex;
            flex-direction: column;
            align-items: center;
            
            background-image: url('page.jpg'); 
            background-size: cover;
            background-position: center;
            font-family: 'Microsoft JhengHei', 'Segoe UI', sans-serif;
            color: #333;
            /* ç¦æ­¢é¸å–èˆ‡ç¸®æ”¾ */
            touch-action: none; 
            user-select: none;  
        }

        .app-layout-wrapper {
            width: 100%;
            max-width: 600px; 
            height: 100%;
            display: flex;
            flex-direction: column;
            position: relative;
            background: transparent;
        }

        /* =========================================
           2. é ‚éƒ¨ï¼šæ¨™é¡Œåˆ— (å›ºå®š)
           ========================================= */
        .main-header {
            flex: 0 0 60px;
            width: 100%;
            background: linear-gradient(90deg, #1a2a6c, #b21f1f, #fdbb2d);
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            z-index: 100;
            display: flex;
            align-items: center;
            padding: 0 15px;
            box-sizing: border-box;
            color: white;
        }

        .logo-area {
            width: 40px;
            height: 40px;
            background-color: white;
            border-radius: 50%;
            margin-right: 15px;
            background-image: url('logo.jpg');
            background-size: cover;
            border: 2px solid #00d2ff;
            flex-shrink: 0;
            cursor: pointer;
        }

        .header-title {
            font-size: 1.0rem;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
            color: white;
            white-space: normal;
            line-height: 1.2;          
            max-height: 2.4em;         
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
            flex: 1;                   
            padding-right: 10px;       
        }

        .line-btn {
            margin-left: auto;
            background-color: #00B900;
            color: white;
            text-decoration: none;
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: bold;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            border: 1px solid rgba(255,255,255,0.5);
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            white-space: nowrap;
        }
        
        .line-btn:active {
            transform: scale(0.95);
            background-color: #009900;
        }

        /* =========================================
           3. ä¸­é–“ï¼šå…§å®¹å€ (å¯æ»¾å‹•)
           ========================================= */
        .content-scroll-area {
            flex: 1 1 auto;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            width: 100%;
            padding: 0;
            padding-bottom: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .ui-card {
            width: 96% !important;
            max-width: 96% !important;
            box-sizing: border-box;
            margin-left: auto;
            margin-right: auto;
            margin-top: 15px;
            
            background: rgba(255, 255, 255, 0.95);
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            border: 1px solid rgba(0,0,0,0.05);
            padding: 12px;
        }

        .topic-description {
            text-align: center;
            color: #444;
            font-size: 0.95rem;
            line-height: 1.5;
        }

        /* =========================================
           4. æ¨¡æ“¬å€èˆ‡å°ˆå±¬æ¨£å¼ (ç§»æ¤è‡ªå°ˆæ¡ˆB)
           ========================================= */
        .simulation-container {
            width: 100%;
            /* å¼·åˆ¶é«˜åº¦ï¼Œç¢ºä¿æ¨¡æ“¬æ“ä½œå€å¤ å¤§ */
            height: 60vh; 
            min-height: 350px;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            margin-top: 5px;
            background: transparent;
            overflow: hidden; /* é˜²æ­¢ canvas æº¢å‡º */
        }

        canvas { display: block; width: 100%; height: 100%; }

        /* æµ®å‹•æç¤ºæ¨™ç±¤ */
        .instruction-tag {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.95);
            padding: 8px 24px;
            border-radius: 50px;
            font-size: 0.95rem;
            color: #555;
            font-weight: 600;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            pointer-events: none; 
            white-space: nowrap;
            backdrop-filter: blur(5px);
            border: 2px solid rgba(0,0,0,0.05);
            transition: all 0.3s ease;
            z-index: 10;
        }

        .instruction-tag.step-active {
            color: #2c3e50;
            border-color: #3498db;
            background: #fff;
            transform: translateX(-50%) scale(1.02);
        }
        
        .instruction-tag.success {
            color: #fff;
            background: var(--ground-color);
            border-color: var(--ground-color);
            box-shadow: 0 4px 20px rgba(39, 174, 96, 0.4);
        }

        /* =========================================
           5. åº•éƒ¨æ§åˆ¶å¡¢ (æ•´åˆå°ˆæ¡ˆBçš„æ§åˆ¶åˆ—)
           ========================================= */
        .controls-dock {
            flex: 0 0 auto;
            width: 100%;
            background: rgba(255, 255, 255, 0.98);
            box-shadow: 0 -4px 15px rgba(0,0,0,0.1);
            z-index: 100;
            padding: 10px 15px;
            box-sizing: border-box;
            
            /* åº•éƒ¨å®‰å…¨å€ */
            padding-bottom: calc(10px + env(safe-area-inset-bottom));
            
            display: flex;
            justify-content: center; /* æ§åˆ¶åˆ—ç½®ä¸­ */
            align-items: center;
        }

        /* ç§»æ¤éä¾†çš„æ§åˆ¶å…ƒä»¶æ¨£å¼ */
        .switch-capsule {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            background: #f1f3f5;
            border-radius: 100px;
            box-shadow: inset 0 2px 6px rgba(0,0,0,0.06);
            padding: 5px 15px; 
            gap: 10px;
        }

        .btn-toggle {
            width: 44px; height: 44px;
            border: none; border-radius: 50%;
            font-size: 1.5rem; font-weight: 800;
            cursor: pointer;
            background: transparent; color: #bdc3c7;
            display: flex; align-items: center; justify-content: center;
            transition: all 0.2s;
            flex-shrink: 0;
            padding: 0; /* é‡ç½® padding */
        }
        
        .btn-toggle:active { transform: scale(0.95); }
        
        .btn-toggle.active-neg { background: #3498db; color: white; box-shadow: 0 4px 12px rgba(52, 152, 219, 0.4); }
        .btn-toggle.active-pos { background: #e74c3c; color: white; box-shadow: 0 4px 12px rgba(231, 76, 60, 0.4); }
        
        .btn-toggle.active-ground { 
            background: var(--ground-color); 
            color: white; 
            box-shadow: 0 4px 12px rgba(39, 174, 96, 0.5); 
        }

        .btn-reset-icon { font-size: 1.4rem; color: #e74c3c; }
        .btn-reset-icon:hover { background: rgba(231, 76, 60, 0.1); }

        .deck-label { font-size: 0.9rem; font-weight: 700; color: #666; white-space: nowrap; margin-right: 5px; }
        .divider { width: 1px; height: 24px; background: #cbd5e0; margin: 0 2px; }

    </style>
</head>
<body>

    <div class="app-layout-wrapper">
        
        <header class="main-header">
            <a href="index.html" class="logo-area" title="è¿”å›å¤§å»³"></a>
            <div class="header-title">æ™Ÿè‡ªç„¶è¼”åŠ©ç³»çµ±<br>æ„Ÿæ‡‰èµ·é›»</div>
            
            <a href="https://line.me/ti/g2/TTCqPpZP6lQqX1z_AUDPNm4977Dvylew3O7oBg" target="_blank" class="line-btn">
                åŠ  LINE è¨è«–
            </a>
        </header>

        <main class="content-scroll-area">
            
            <div class="simulation-container" id="sim-container">
                <div class="instruction-tag" id="infoTag">æ­¥é©Ÿ1ï¼šè«‹æ‹–æ›³å¸¶é›»æ£’é è¿‘é‡‘å±¬çƒ</div>
                <canvas id="simCanvas"></canvas>
            </div>
            
            <div class="ui-card topic-description">
                <b>æ“ä½œèªªæ˜ï¼š</b>æ‹–æ›³å¸¶é›»æ£’é è¿‘é‡‘å±¬çƒï¼Œè§€å¯Ÿé›»è·åˆ†é›¢ç¾è±¡ã€‚é©æ™‚é»æ“Šä¸‹æ–¹ã€Œæ¥åœ°ã€æŒ‰éˆ•ï¼Œè§€å¯Ÿé›»å­æµå‘ã€‚
            </div>

        </main>

        <footer class="controls-dock" id="controls-area">
            <div class="switch-capsule">
                <span class="deck-label">å¸¶é›»æ£’</span>
                
                <button class="btn-toggle active-neg" id="btnNeg" onclick="APP.setRod(-1)">ï¼</button>
                <button class="btn-toggle" id="btnPos" onclick="APP.setRod(1)">ï¼‹</button>
                
                <div class="divider"></div>
                
                <button class="btn-toggle" id="btnGround" onclick="APP.toggleGround()" title="æ¥åœ°">
                    ğŸ–
                </button>
                
                <button class="btn-toggle btn-reset-icon" onclick="APP.reset()" title="é‡ç½®">
                    â†º
                </button>
            </div>
        </footer>

    </div>

    <script>
        /**
         * Project B: Induction Charging (Integrated into Template)
         */
        const APP = {
            canvas: null,
            ctx: null,
            wrapper: null,
            width: 0,
            height: 0,
            dpr: 1,

            conductor: { x: 0, y: 0, r: 0 },
            rod: { x: 0, y: 0, charge: -1, dragging: false, angle: 0 }, 
            
            particles: [], 
            protons: [],   
            flowParticles: [], 
            
            state: {
                inductionLevel: 0,
                isGrounded: false,
                flowTimer: 0
            },

            CONFIG: {
                radiusBase: 90,     
                particleSize: 15,
                k_rod: 120000,
                k_self: 8000, 
                damping: 0.85, 
                rodLen: 100,        
                rodW: 34,           
                gap: 50,            
                inductionThreshold: 160,
                groundY: 0,
                wireX: 0
            },

            init: function() {
                this.wrapper = document.getElementById('sim-container');
                this.canvas = document.getElementById('simCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.dpr = window.devicePixelRatio || 1;

                const bind = (evts, handler) => evts.forEach(e => this.canvas.addEventListener(e, handler, {passive: false}));
                bind(['mousedown', 'mousemove', 'mouseup', 'mouseleave'], e => this.handleMouse(e));
                bind(['touchstart', 'touchmove', 'touchend'], e => this.handleTouch(e));
                
                window.addEventListener('resize', () => this.resize());

                this.resize();
                this.loop();
                console.log("æ„Ÿæ‡‰èµ·é›»æ¨¡æ“¬åˆå§‹åŒ–å®Œæˆ");
            },

            resize: function() {
                const rect = this.wrapper.getBoundingClientRect();
                this.width = rect.width;
                this.height = rect.height;
                
                this.canvas.width = this.width * this.dpr;
                this.canvas.height = this.height * this.dpr;
                this.ctx.scale(this.dpr, this.dpr);

                // ç´€éŒ„èˆŠçš„æ¯”ä¾‹ä½ç½®ï¼Œé¿å… Resize æ™‚å¸¶é›»æ£’ä½ç½®è·‘æ‰
                let oldRodXRatio = 0.85;
                let oldRodYRatio = 0.85;
                if(this.rod.x !== 0 && this.conductor.x !== 0) {
                     // ç°¡å–®ä¿è­·ï¼šå¦‚æœä¸æ˜¯åˆæ¬¡åŸ·è¡Œï¼Œå‰‡å˜—è©¦ä¿æŒç›¸å°ä½ç½®
                     // ä½†ç‚ºäº†ç°¡å–®èµ·è¦‹ï¼ŒResize å¾Œæˆ‘å€‘å°‡å¸¶é›»æ£’å¾©ä½åˆ°å®‰å…¨å€åŸŸï¼Œé¿å…å¡åœ¨ç‰†å¤–
                     // æˆ–è€…ä¿æŒç¾æœ‰é‚è¼¯ï¼Œåƒ…é‡æ–°è¨ˆç®—ç‰©ç†ä¸­å¿ƒ
                }

                this.conductor.x = this.width / 2;
                this.conductor.y = this.height / 2 - 40; // ç¨å¾®ä¸Šç§»ä»¥é©æ‡‰ä¸‹æ–¹æ§åˆ¶åˆ—
                this.CONFIG.groundY = this.height - 20; 
                
                let scale = Math.min(this.width, this.height) / 400;
                this.conductor.r = this.CONFIG.radiusBase * scale;
                this.CONFIG.wireX = this.conductor.x + this.conductor.r + 30; 
                
                this.rodSize = {
                    L: this.CONFIG.rodLen * scale,
                    W: this.CONFIG.rodW * scale
                };

                // è‹¥æ˜¯åˆå§‹åŒ–æˆ–é‡ç½®ç‹€æ…‹
                if (this.protons.length === 0) {
                    this.initParticles();
                    this.rod.x = this.width * 0.85; 
                    this.rod.y = this.height * 0.85;
                } else {
                    // Resize æ™‚ç¢ºä¿å¸¶é›»æ£’ä¸éºå¤±ï¼Œå¼·åˆ¶æ­¸ä½åˆ°å³ä¸‹è§’å®‰å…¨å€ (UX å„ªåŒ–)
                    // ä¹Ÿå¯ä»¥é¸æ“‡ä¸è®Šå‹•ï¼Œä½†åœ¨ä¸åŒé•·å¯¬æ¯”åˆ‡æ›æ™‚æœƒæœ‰é¢¨éšªã€‚é€™è£¡é¸æ“‡ä¿å®ˆç­–ç•¥ã€‚
                    // é€™è£¡åƒ…é€²è¡Œé‚Šç•Œæª¢æŸ¥
                    if(this.rod.x > this.width) this.rod.x = this.width - 50;
                    if(this.rod.y > this.height) this.rod.y = this.height - 50;
                }
            },

            reset: function() {
                this.state.isGrounded = false;
                this.state.flowTimer = 0;
                this.flowParticles = [];
                // é‡ç½®ä½ç½®
                this.rod.x = this.width * 0.85;
                this.rod.y = this.height * 0.85;
                this.rod.angle = -Math.PI/4;
                this.initParticles();
                this.updateUI();
            },

            initParticles: function() {
                this.particles = [];
                this.protons = [];
                const {x, y, r} = this.conductor;
                const offset = r * 0.4;

                const pos = [
                    {x: x-offset, y: y-offset}, {x: x+offset, y: y-offset},
                    {x: x-offset, y: y+offset}, {x: x+offset, y: y+offset}
                ];

                pos.forEach(p => {
                    this.protons.push({x: p.x, y: p.y});
                    this.particles.push({
                        x: p.x + (Math.random()-0.5)*5,
                        y: p.y + (Math.random()-0.5)*5,
                        vx: 0, vy: 0
                    });
                });
            },

            update: function() {
                let dxRod = this.conductor.x - this.rod.x;
                let dyRod = this.conductor.y - this.rod.y;
                this.rod.angle = Math.atan2(dyRod, dxRod); 
                let halfL = this.rodSize.L / 2;
                let tipX = this.rod.x + Math.cos(this.rod.angle) * halfL;
                let tipY = this.rod.y + Math.sin(this.rod.angle) * halfL;

                let distToCenter = Math.sqrt(dxRod*dxRod + dyRod*dyRod);
                let surfaceDist = distToCenter - this.conductor.r - halfL;
                let maxEffectDist = this.CONFIG.inductionThreshold;
                if (surfaceDist < 0) surfaceDist = 0;
                
                if (surfaceDist > maxEffectDist) {
                    this.state.inductionLevel = 0;
                } else {
                    this.state.inductionLevel = 1 - (surfaceDist / maxEffectDist);
                }

                this.updateGroundingLogic();

                const scale = this.width / 400;
                const pR = this.CONFIG.particleSize * scale;
                
                let forceMult = (this.rod.charge === 1) ? 2.5 : 1.0; 
                const rodForceBase = this.CONFIG.k_rod * scale * forceMult;
                const selfForceBase = this.CONFIG.k_self * scale;

                this.particles.forEach((p) => {
                    let fx = 0, fy = 0;
                    let dx = p.x - tipX;
                    let dy = p.y - tipY;
                    let distSq = dx*dx + dy*dy;
                    let minD = (this.rod.charge === 1) ? 60 : 100;
                    if (distSq < minD) distSq = minD;
                    let rodF = rodForceBase / distSq;
                    let dist = Math.sqrt(distSq);

                    if (this.state.inductionLevel > 0) {
                        if (this.rod.charge === -1) { 
                            fx += (dx / dist) * rodF; fy += (dy / dist) * rodF; 
                        } else { 
                            fx -= (dx / dist) * rodF; fy -= (dy / dist) * rodF; 
                        }
                    }

                    this.particles.forEach((other) => {
                        if (p === other) return;
                        let odx = p.x - other.x;
                        let ody = p.y - other.y;
                        let od2 = odx*odx + ody*ody;
                        let od = Math.sqrt(od2);
                        if (od < 0.1) od = 0.1;
                        let repF = selfForceBase / (od2 + 10);
                        fx += (odx/od) * repF;
                        fy += (ody/od) * repF;
                    });

                    p.vx = (p.vx + fx) * this.CONFIG.damping;
                    p.vy = (p.vy + fy) * this.CONFIG.damping;
                    
                    let speed = Math.sqrt(p.vx*p.vx + p.vy*p.vy);
                    if (speed > 8) {
                        p.vx = (p.vx/speed)*8;
                        p.vy = (p.vy/speed)*8;
                    }
                    p.x += p.vx;
                    p.y += p.vy;
                });

                const iterations = 3; 
                for(let k=0; k<iterations; k++) {
                    this.particles.forEach((p, i) => {
                        let cdx = p.x - this.conductor.x;
                        let cdy = p.y - this.conductor.y;
                        let cDist = Math.sqrt(cdx*cdx + cdy*cdy);
                        let limitR = this.conductor.r - pR - 2;

                        if (cDist > limitR) {
                            let ang = Math.atan2(cdy, cdx);
                            p.x = this.conductor.x + limitR * Math.cos(ang);
                            p.y = this.conductor.y + limitR * Math.sin(ang);
                            p.vx *= 0.1; p.vy *= 0.1;
                        }

                        for (let j = i + 1; j < this.particles.length; j++) {
                            let p2 = this.particles[j];
                            let dx = p.x - p2.x;
                            let dy = p.y - p2.y;
                            let dist = Math.sqrt(dx*dx + dy*dy);
                            let minDist = pR * 2 + 2; 

                            if (dist < minDist) {
                                let overlap = minDist - dist;
                                let nx = dx / dist;
                                let ny = dy / dist;
                                p.x += nx * overlap * 0.5;
                                p.y += ny * overlap * 0.5;
                                p2.x -= nx * overlap * 0.5;
                                p2.y -= ny * overlap * 0.5;
                            }
                        }
                    });
                }
                this.updateFlowParticles();
                this.updateInstruction();
            },

            updateGroundingLogic: function() {
                if (!this.state.isGrounded) return;
                if (this.state.inductionLevel < 0.2) return; 

                this.state.flowTimer++;
                if (this.state.flowTimer < 10) return; 
                
                let currentCount = this.particles.length;
                let targetCount = 4; 
                if (this.rod.charge === 1) targetCount = 8;
                if (this.rod.charge === -1) targetCount = 0;

                if (currentCount < targetCount) {
                    if (this.flowParticles.length === 0) {
                        this.spawnFlowParticle('up');
                        this.state.flowTimer = 0;
                    }
                } else if (currentCount > targetCount) {
                    if (this.flowParticles.length === 0) {
                        this.particles.pop(); 
                        this.spawnFlowParticle('down');
                        this.state.flowTimer = 0;
                    }
                }
            },

            spawnFlowParticle: function(dir) {
                let wireX = this.CONFIG.wireX;
                let startY = (dir === 'up') ? this.CONFIG.groundY : this.conductor.y;
                
                this.flowParticles.push({
                    x: wireX, y: startY,
                    vy: (dir === 'up') ? -20 : 20, 
                    dir: dir, active: true
                });
            },

            updateFlowParticles: function() {
                for(let i = this.flowParticles.length-1; i>=0; i--) {
                    let p = this.flowParticles[i];
                    p.y += p.vy;
                    let hitSphere = (p.dir === 'up' && p.y <= this.conductor.y);
                    let hitGround = (p.dir === 'down' && p.y >= this.CONFIG.groundY);

                    if (p.active) {
                        if (hitSphere) {
                            this.particles.push({
                                x: this.conductor.x + this.conductor.r - 10,
                                y: this.conductor.y,
                                vx: -5, vy: 0
                            });
                            p.active = false;
                        } else if (hitGround) {
                            p.active = false;
                        }
                    }
                    if (p.y < this.conductor.y - 100 || p.y > this.CONFIG.groundY + 100 || !p.active) {
                        this.flowParticles.splice(i, 1);
                    }
                }
            },

            updateInstruction: function() {
                const tag = document.getElementById('infoTag');
                const level = this.state.inductionLevel;
                const grounded = this.state.isGrounded;
                const eCount = this.particles.length;
                
                let msg = "";
                let className = "instruction-tag";
                
                if (!grounded) {
                    if (level < 0.2) {
                        if (eCount === 4) {
                            msg = "æ­¥é©Ÿ1ï¼šè«‹æ‹–æ›³å¸¶é›»æ£’é è¿‘é‡‘å±¬çƒ";
                            className += " step-active";
                        } else {
                            let charge = eCount > 4 ? "è² " : "æ­£";
                            msg = `å¯¦é©—å®Œæˆï¼šé‡‘å±¬çƒå¸¶${charge}é›»`;
                            className += " success";
                        }
                    } else {
                        msg = "æ­¥é©Ÿ2ï¼šå¸¶é›»æ£’ä¸å‹•ï¼Œé»æ“Šä¸‹æ–¹ã€Œæ¥åœ°ã€";
                        className += " step-active";
                    }
                } else {
                    let isBalanced = false;
                    if (this.rod.charge === 1 && eCount === 8) isBalanced = true;
                    if (this.rod.charge === -1 && eCount === 0) isBalanced = true;
                    
                    if (isBalanced) {
                        msg = "æ­¥é©Ÿ3ï¼šè«‹ã€Œæ–·é–‹æ¥åœ°ã€é–å®šé›»è·";
                    } else {
                        msg = "æ­¥é©Ÿ3ï¼šè§€å¯Ÿé›»å­æµå‹•æ–¹å‘";
                    }
                    className += " step-active";
                }
                
                if (!grounded && level >= 0.2 && eCount !== 4) {
                    msg = "æ­¥é©Ÿ4ï¼šè«‹ç§»é–‹å¸¶é›»æ£’";
                }
                if (tag.innerText !== msg) tag.innerText = msg;
                tag.className = className;
            },

            toggleGround: function() {
                if (this.state.inductionLevel < 0.2) return;
                this.state.isGrounded = !this.state.isGrounded;
                this.updateUI();
            },

            updateUI: function() {
                const btn = document.getElementById('btnGround');
                if (this.state.isGrounded) {
                    btn.classList.add('active-ground');
                } else {
                    btn.classList.remove('active-ground');
                }
            },

            draw: function() {
                this.ctx.clearRect(0, 0, this.width, this.height);
                this.drawFloor();
                this.drawConductor(); 
                if (this.state.isGrounded) this.drawGroundSystem();
                
                this.protons.forEach(p => this.drawCharge(p.x, p.y, '#e74c3c', '+'));
                this.particles.forEach(p => this.drawCharge(p.x, p.y, '#3498db', '-'));
                this.flowParticles.forEach(p => this.drawCharge(p.x, p.y, '#3498db', '-'));
                this.drawRod();
            },

            drawFloor: function() {
                const y = this.CONFIG.groundY;
                this.ctx.lineCap = 'butt';
                this.ctx.beginPath();
                this.ctx.moveTo(0, y);
                this.ctx.lineTo(this.width, y);
                this.ctx.strokeStyle = '#7f8c8d'; 
                this.ctx.lineWidth = 2;
                this.ctx.stroke();

                this.ctx.beginPath();
                for(let i=0; i<this.width; i+=25) {
                    this.ctx.moveTo(i, y);
                    this.ctx.lineTo(i-15, y+15);
                }
                this.ctx.strokeStyle = '#95a5a6';
                this.ctx.lineWidth = 1;
                this.ctx.stroke();
            },

            drawGroundSystem: function() {
                const y = this.CONFIG.groundY;
                const wireX = this.CONFIG.wireX;
                const {x, r} = this.conductor;
                const cy = this.conductor.y;

                this.ctx.lineCap = 'round';
                this.ctx.lineJoin = 'round';

                this.ctx.beginPath();
                this.ctx.moveTo(x + r + 20, cy); 
                this.ctx.lineTo(wireX, cy); 
                this.ctx.lineTo(wireX, y); 
                this.ctx.strokeStyle = '#000000'; 
                this.ctx.lineWidth = 4;
                this.ctx.stroke();

                this.ctx.strokeStyle = '#000000'; 
                this.ctx.lineWidth = 4;
                this.ctx.beginPath();
                this.ctx.moveTo(wireX, y);
                this.ctx.lineTo(wireX, y + 15);
                this.ctx.stroke();
                
                this.ctx.beginPath();
                this.ctx.moveTo(wireX - 18, y + 15);
                this.ctx.lineTo(wireX + 18, y + 15);
                this.ctx.stroke();
                
                this.ctx.beginPath();
                this.ctx.moveTo(wireX - 12, y + 22);
                this.ctx.lineTo(wireX + 12, y + 22);
                this.ctx.stroke();
                
                this.ctx.beginPath();
                this.ctx.moveTo(wireX - 6, y + 29);
                this.ctx.lineTo(wireX + 6, y + 29);
                this.ctx.stroke();

                this.ctx.save();
                this.ctx.font = "40px Arial";
                this.ctx.textAlign = "center";
                this.ctx.textBaseline = "middle";
                this.ctx.translate(x + r + 15, cy + 15);
                this.ctx.rotate(-1.57); 
                this.ctx.fillText("ğŸ‘†", 0, 0);
                this.ctx.restore();

                if (this.state.isGrounded) {
                    let chars = [];
                    let arrow = "";
                    if (this.rod.charge === 1) { 
                        chars = ["é›»","å­","å¾","åœ°","çƒ","æµ","å…¥"]; arrow = "â†‘";
                    } else { 
                        chars = ["é›»","å­","å¾","é‡‘","å±¬","çƒ","æµ","å‡º"]; arrow = "â†“";
                    }
                    if (chars.length > 0) {
                        this.ctx.fillStyle = "#2c3e50"; 
                        this.ctx.font = "bold 24px 'Microsoft JhengHei', Arial"; 
                        this.ctx.textAlign = "center";
                        this.ctx.textBaseline = "middle";

                        let textX = wireX - 45;
                        let centerY = (y + cy) / 2;
                        let startY = centerY - (chars.length * 28) / 2;
                        
                        for(let i=0; i<chars.length; i++) {
                            this.ctx.fillText(chars[i], textX, startY + i*28);
                        }
                        this.ctx.fillStyle = "#e74c3c"; 
                        this.ctx.font = "bold 40px Arial";
                        this.ctx.fillText(arrow, wireX + 40, centerY);
                    }
                }
            },

            drawConductor: function() {
                const {x, y, r} = this.conductor;
                this.ctx.fillStyle = '#5d4037'; 
                let baseW = 80;
                let baseH = 15;
                this.ctx.fillRect(x - baseW/2, this.CONFIG.groundY - baseH, baseW, baseH);

                let standW = 16;
                let standH = (this.CONFIG.groundY - baseH) - (y + r);
                this.ctx.fillStyle = '#95a5a6';
                this.ctx.fillRect(x - standW/2, y + r - 2, standW, standH + 2);
                
                this.ctx.beginPath();
                this.ctx.arc(x, y, r, 0, Math.PI*2);
                let grad = this.ctx.createRadialGradient(x - r*0.3, y - r*0.3, r*0.1, x, y, r);
                grad.addColorStop(0, '#f8f9fa');
                grad.addColorStop(1, '#95a5a6');
                this.ctx.fillStyle = grad;
                this.ctx.fill();

                this.ctx.beginPath();
                this.ctx.arc(x, y, r, 0, Math.PI*2);
                this.ctx.lineWidth = 2;
                this.ctx.strokeStyle = '#bdc3c7';
                this.ctx.stroke();
            },

            drawCharge: function(x, y, color, symbol) {
                const r = this.CONFIG.particleSize * (this.width / 400); 
                this.ctx.beginPath();
                this.ctx.arc(x, y, r, 0, Math.PI*2);
                this.ctx.fillStyle = '#fff';
                this.ctx.fill();
                this.ctx.lineWidth = 2;
                this.ctx.strokeStyle = color;
                this.ctx.stroke();

                this.ctx.fillStyle = color;
                this.ctx.font = `bold ${r*1.2}px Arial`;
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                this.ctx.fillText(symbol, x, y + 1);
            },

            drawRod: function() {
                this.ctx.save();
                this.ctx.translate(this.rod.x, this.rod.y);
                this.ctx.rotate(this.rod.angle); 

                const L = this.rodSize.L;
                const W = this.rodSize.W;
                const chargeColor = this.rod.charge < 0 ? '#3498db' : '#e74c3c';
                const symbol = this.rod.charge < 0 ? '-' : '+';
                
                this.ctx.fillStyle = (this.rod.charge < 0) ? '#34495e' : 'rgba(236, 240, 241, 0.95)';
                this.ctx.beginPath();
                // [Essential Fix]: Replaced roundRect with standard arc/lineTo for compatibility
                const radius = W / 2;
                this.ctx.moveTo(-L/2 + radius, -W/2);
                this.ctx.lineTo(L/2 - radius, -W/2);
                this.ctx.quadraticCurveTo(L/2, -W/2, L/2, -W/2 + radius);
                this.ctx.lineTo(L/2, W/2 - radius);
                this.ctx.quadraticCurveTo(L/2, W/2, L/2 - radius, W/2);
                this.ctx.lineTo(-L/2 + radius, W/2);
                this.ctx.quadraticCurveTo(-L/2, W/2, -L/2, W/2 - radius);
                this.ctx.lineTo(-L/2, -W/2 + radius);
                this.ctx.quadraticCurveTo(-L/2, -W/2, -L/2 + radius, -W/2);
                
                this.ctx.fill();
                this.ctx.strokeStyle = '#bdc3c7';
                this.ctx.lineWidth = 1;
                this.ctx.stroke();

                const headX = L/2 - W/2;
                const headR = W * 0.8;
                this.ctx.beginPath();
                this.ctx.arc(headX, 0, headR, 0, Math.PI*2);
                this.ctx.fillStyle = '#fff'; 
                this.ctx.fill();
                this.ctx.strokeStyle = chargeColor; 
                this.ctx.lineWidth = 4;
                this.ctx.stroke();

                this.ctx.fillStyle = chargeColor;
                this.ctx.font = 'bold 28px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                this.ctx.fillText(symbol, headX, 2);

                this.ctx.fillStyle = '#2c3e50';
                this.ctx.fillRect(-L/2, -W/2, 40, W); 
                this.ctx.strokeStyle = '#555';
                this.ctx.lineWidth = 2;
                for(let i=0; i<3; i++) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(-L/2 + 10 + i*10, -W/2);
                    this.ctx.lineTo(-L/2 + 10 + i*10, W/2);
                    this.ctx.stroke();
                }
                this.ctx.restore();
            },

            handleMouse: function(e) {
                if (e.type === 'mousedown') this.startDrag(e);
                else if (e.type === 'mousemove') this.drag(e);
                else if (e.type === 'mouseup' || e.type === 'mouseleave') this.endDrag(e);
            },

            handleTouch: function(e) {
                e.preventDefault();
                if (e.type === 'touchstart') this.startDrag(e);
                else if (e.type === 'touchmove') this.drag(e);
                else if (e.type === 'touchend') this.endDrag(e);
            },

            getPos: function(e) {
                const rect = this.canvas.getBoundingClientRect();
                let cx, cy;
                if (e.touches && e.touches.length > 0) {
                    cx = e.touches[0].clientX;
                    cy = e.touches[0].clientY;
                } else if (e.clientX !== undefined) {
                    cx = e.clientX;
                    cy = e.clientY;
                } else {
                    return {x: this.rod.x, y: this.rod.y};
                }
                return { x: cx - rect.left, y: cy - rect.top };
            },

            startDrag: function(e) {
                let p = this.getPos(e);
                let dist = Math.sqrt(Math.pow(p.x - this.rod.x, 2) + Math.pow(p.y - this.rod.y, 2));
                if (dist < 150) {
                    this.rod.dragging = true;
                    this.updateRodPos(p.x, p.y);
                }
            },

            drag: function(e) {
                if (!this.rod.dragging) return;
                let p = this.getPos(e);
                this.updateRodPos(p.x, p.y);
            },

            endDrag: function() {
                this.rod.dragging = false;
            },

            updateRodPos: function(targetX, targetY) {
                let dxRod = this.conductor.x - targetX;
                let dyRod = this.conductor.y - targetY;
                let angle = Math.atan2(dyRod, dxRod);

                let halfL = this.rodSize.L / 2;
                let tipX = targetX + Math.cos(angle) * halfL;
                let tipY = targetY + Math.sin(angle) * halfL;

                tipX = Math.max(0, Math.min(this.width, tipX));
                tipY = Math.max(0, Math.min(this.height, tipY));

                this.rod.x = tipX - Math.cos(angle) * halfL;
                this.rod.y = tipY - Math.sin(angle) * halfL;

                let finalDx = this.conductor.x - this.rod.x;
                let finalDy = this.conductor.y - this.rod.y;
                let dist = Math.sqrt(finalDx*finalDx + finalDy*finalDy);
                let minSafeDist = halfL + this.conductor.r + this.CONFIG.gap;

                if (dist < minSafeDist) {
                     this.rod.x = this.conductor.x - Math.cos(angle) * minSafeDist;
                     this.rod.y = this.conductor.y - Math.sin(angle) * minSafeDist;
                }
            },

            setRod: function(c) {
                this.rod.charge = c;
                this.reset(); 
                document.getElementById('btnNeg').className = c===-1 ? 'btn-toggle active-neg' : 'btn-toggle';
                document.getElementById('btnPos').className = c===1 ? 'btn-toggle active-pos' : 'btn-toggle';
            },

            loop: function() {
                this.update();
                this.draw();
                requestAnimationFrame(() => this.loop());
            }
        };

        window.addEventListener('load', () => APP.init());

    </script>
</body>
</html>