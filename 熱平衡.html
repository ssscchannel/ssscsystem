<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    
    <title>晟自然輔助系統　熱平衡互動模擬</title>
    
    <style>
        /* =========================================
           1. 核心架構：App Shell
           ========================================= */
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100dvh;
            overflow: hidden;
            
            display: flex;
            flex-direction: column;
            align-items: center;
            
            background-image: url('page.jpg'); 
            background-size: cover;
            background-position: center;
            font-family: 'Microsoft JhengHei', 'Segoe UI', sans-serif;
            color: #333;
        }

        .app-layout-wrapper {
            width: 100%;
            max-width: 600px;
            height: 100%;
            display: flex;
            flex-direction: column;
            position: relative;
            background: transparent;
        }

        /* =========================================
           2. 頂部導航列
           ========================================= */
        .main-header {
            flex: 0 0 60px;
            width: 100%;
            background: linear-gradient(90deg, #1a2a6c, #b21f1f, #fdbb2d);
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            z-index: 100;
            display: flex;
            align-items: center;
            padding: 0 15px;
            box-sizing: border-box;
            color: white;
        }

        .logo-area {
            width: 40px;
            height: 40px;
            background-color: white;
            border-radius: 50%;
            margin-right: 15px;
            background-image: url('logo.jpg');
            background-size: cover;
            border: 2px solid rgba(255,255,255,0.8);
            flex-shrink: 0;
        }

        .header-title {
            font-size: 1.0rem;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
            color: white;
            white-space: normal;
            line-height: 1.2;          
            max-height: 2.4em;         
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
            flex: 1;                   
            padding-right: 10px;       
        }

        .line-btn {
            margin-left: auto;
            background-color: #00B900;
            color: white;
            text-decoration: none;
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: bold;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            border: 1px solid rgba(255,255,255,0.5);
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            white-space: nowrap;
        }

        /* =========================================
           3. 中間滾動內容區
           ========================================= */
        .content-scroll-area {
            flex: 1 1 auto;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            width: 100%;
            padding: 0;
            padding-bottom: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        /* 3-1. 模擬視覺區 */
        .simulation-container {
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: flex-end;
            position: relative;
            margin-top: 10px;
            height: 220px;
            padding-bottom: 10px;
            
            /* 新增這一行：確保空間不足時，動畫區塊不會被壓縮 */
            flex-shrink: 0; 
        }

        .beaker-group {
            display: flex;
            align-items: flex-end;
            gap: 20px;
            position: relative;
        }

        .beaker {
            width: 80px;
            border: 3px solid #555;
            border-top: none;
            border-radius: 0 0 10px 10px;
            background: rgba(255,255,255,0.5);
            position: relative;
            display: flex;
            align-items: flex-end;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .water {
            width: 100%;
            transition: height 0.3s ease, background-color 0.5s ease;
            border-radius: 0 0 7px 7px;
            position: relative;
            overflow: hidden;
        }
        
        .label-temp {
            position: absolute;
            top: -25px;
            width: 100%;
            text-align: center;
            font-weight: bold;
            font-size: 0.9rem;
            color: #333;
            background: rgba(255,255,255,0.8);
            border-radius: 4px;
            padding: 2px 0;
        }

        #mix-beaker {
            width: 120px;
            height: 180px;
            display: none;
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
        }

        /* 3-2. 參數設定面板 (Footer 版適配) */
        .settings-panel {
            width: 100% !important;      /* 填滿 Footer 的內部空間 */
            box-sizing: border-box;
            background: #f4f6f9;         /* 改個底色稍微區隔，或維持白色皆可 */
            border-radius: 12px;
            padding: 8px 10px;
            margin: 0; 
            display: block;
        }

        /* 新增：模式切換列 */
        .mode-switch-row {
            display: flex;
            gap: 8px;
            margin-bottom: 6px;
            padding-bottom: 4px;
            border-bottom: 1px dashed #ddd;
        }
        .mode-btn {
            flex: 1;
            padding: 6px 0;
            text-align: center;
            background: #f0f2f5;
            color: #666;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: bold;
            transition: all 0.2s;
        }
        .mode-btn.active {
            background: #2d3436;
            color: #fff;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        /* 新增：參數輸入網格 (雙欄) */
        .params-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 6px;
        }
		
		/* 新增：參數並排容器 */
		.param-row {
    		display: flex;
			gap: 5px; /* 欄位間距 */
			margin-bottom: 2px;
		}
		
		.param-item {
    		flex: 1; /* 平均分配寬度 */
			min-width: 0; /* 防止輸入框撐開 */
		}

        .param-col-header {
            text-align: center;
            font-weight: bold;
            font-size: 0.9rem;
            margin-bottom: 4px;
            padding-bottom: 2px;
            border-bottom: 2px solid #eee;
        }
        .param-col-header.cold { color: #0984e3; border-color: #74b9ff; }
        .param-col-header.hot { color: #d63031; border-color: #ff7675; }

        /* 輸入框組微調 */
        .input-group { margin-bottom: 8px; }
        .input-group label { display: block; font-size: 0.8rem; color: #666; margin-bottom: 2px; }
        .input-box {
            width: 100%;
            padding: 4px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 0.95rem;
			box-sizing: border-box;
			background: #fff;
			text-align: center;
            height: 32px;
        }
        .input-box:focus { border-color: #0984e3; background: #fff; }
        
        /* 新增：末溫輸入區 */
        .final-row {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            background: #f9f9f9;
            padding: 5px;
            border-radius: 8px;
            margin-top: 4px;
        }

        .input-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .input-group label {
            font-size: 0.9rem;
            font-weight: bold;
            color: #555;
        }

        /* 數字輸入框樣式 */
        .input-box {
            width: 100%;
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 6px;
            font-size: 1rem;
            box-sizing: border-box;
            background: #fff;
            text-align: center;
        }
        
        .input-box:focus {
            border-color: #4d79ff;
            outline: none;
            background: #f0f8ff;
        }

        /* 3-3. 算式區 */
        .info-container {
            width: 96% !important;
            max-width: 96% !important;
            box-sizing: border-box;
            
            /* === 修改這裡：讓底框完全透明消失 === */
            background: transparent;  /* 原本是 rgba(255, 255, 255, 0.9) */
            box-shadow: none;         /* 移除陰影 */
            border: none;             /* 移除邊框 */
            /* ================================= */

            border-radius: 12px;
            padding: 0;               /* 建議把內距也歸零，讓算式貼齊 */
            margin-top: 4px;
            margin-left: auto;
            margin-right: auto;
            min-height: 0;            /* 移除最小高度，避免佔位 */
        }

        .math-step {
            font-size: 1rem;
            margin-bottom: 8px;
            opacity: 0;
            transform: translateX(-10px);
            transition: all 0.5s ease;
            border-left: 3px solid #b21f1f;
            padding-left: 8px;
            background: rgba(240, 240, 240, 0.5);
        }
        .math-step.visible {
            opacity: 1;
            transform: translateX(0);
        }
        .math-highlight {
            color: #d63031;
            font-weight: bold;
        }

        /* =========================================
           4. 底部控制塢 (只保留按鈕)
           ========================================= */
        .controls-dock {
            flex: 0 0 auto;
            width: 100%;
            background: rgba(255, 255, 255, 0.98);
            box-shadow: 0 -4px 15px rgba(0,0,0,0.1);
            z-index: 100;
            
            /* [修改前] padding: 15px; padding-bottom: env(...); */
            
            /* [修改後] 統一設定內距，並特別加高底部 */
            padding: 15px;  /* 上左右保持 15px */
            
            /* 關鍵語法：基礎 20px 空隙 + 手機底部安全區(若有的話) */
            padding-bottom: calc(20px + env(safe-area-inset-bottom));
            
            box-sizing: border-box;
            
            display: flex; /* 確保內容對齊 */
            flex-direction: column; /* 垂直排列 */
            gap: 10px; /* 元件之間的間距 */
        }

        .action-btn {
            width: 100%;
            padding: 12px;
            border: none;
            border-radius: 8px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            font-size: 1.1rem;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
        }
        .action-btn:active {
            transform: scale(0.98);
        }
        .action-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }
        
        .reset-btn {
            background: #636e72;
        }
		
		.topic-description {
            width: 96% !important;
			max-width: 96% !important;
			box-sizing: border-box; /* 確保內距不會撐大框框 */
            background: rgba(255, 255, 255, 0.95); /* 實心白底 */
            border-radius: 12px;                   /* 圓角 */
            padding: 12px;                         /* 內距 */
            margin-top: 15px;
			margin-left: auto;      /* 水平置中 */
			margin-right: auto;     /* 水平置中 */
            box-shadow: 0 2px 8px rgba(0,0,0,0.1); /* 增加立體陰影 */
            
            /* 文字排版 */
            text-align: center;
            color: #444;
            font-size: 0.95rem;
            line-height: 1.5;
            border: 1px solid rgba(0,0,0,0.05);    /* 微細邊框 */           
        }
		
		/* 新增：水平排列專用樣式 (用於比熱) */
.input-group.inline {
    display: flex !important;
    flex-direction: row !important; /* 關鍵：強制橫向排列，覆蓋原本的 column */
    align-items: center !important;
    gap: 8px;
}

.input-group.inline label {
    margin-bottom: 0 !important;
    white-space: nowrap !important; /* 文字不換行 */
    width: auto !important;
}

.input-group.inline .input-box {
    flex: 1 !important;    /* 自動填滿剩餘空間 */
    width: 0 !important;   /* 關鍵：防止預設寬度撐開容器 */
    min-width: 0 !important;
}

/* === 還原：原始燒杯視覺樣式 (DOM Render) === */

/* 視圖層控制 (用於切換 Canvas 與 DOM) */
.view-layer {
    width: 100%;
    height: 100%;
    display: none; /* 預設隱藏 */
    align-items: flex-end;
    justify-content: center;
}
.view-layer.active {
    display: flex; /* 啟動時顯示 */
}

/* 燒杯群組 */
.beaker-group {
    display: flex;
    align-items: flex-end;
    gap: 30px;
    padding-bottom: 20px; /* 底部留白 */
}

/* 燒杯本體 */
.beaker {
    width: 70px;
    height: 110px; /* 固定高度 */
    border: 3px solid #555;
    border-top: none;
    border-radius: 0 0 10px 10px;
    background: rgba(255,255,255,0.6); /* 稍微透明 */
    position: relative;
    display: flex;
    align-items: flex-end;
    justify-content: center;
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
}

/* 水位 */
.water {
    width: 100%;
    border-radius: 0 0 7px 7px;
    transition: height 0.3s ease, background-color 0.3s ease;
    position: relative;
    min-height: 0px;
}

/* 溫度標籤 (浮在杯子上) */
.label-temp {
    position: absolute;
    top: -25px;
    width: 100%;
    text-align: center;
    font-weight: bold;
    font-size: 0.9rem;
    color: #333;
    background: rgba(255,255,255,0.7);
    padding: 2px 0;
    border-radius: 4px;
}

    </style>
</head>
<body>

    <div class="app-layout-wrapper">
        
        <header class="main-header">
            <div class="logo-area"></div>
            <div class="header-title">
                晟自然輔助系統<br>
                熱平衡互動模擬實驗
            </div>
            <a href="https://line.me/ti/g2/TTCqPpZP6lQqX1z_AUDPNm4977Dvylew3O7oBg" target="_blank" class="line-btn">加 LINE 討論</a>
        </header>

        <main class="content-scroll-area">
                     
            <div class="topic-description">
                選擇模式，設定參數，按下「開始混合」觀察實驗結果。<br>
                
            </div>
			
			<div class="simulation-container" id="sim-container">
                <div id="view-liquid" class="view-layer active">
        
        <div class="beaker-group" id="initial-group">
            <div class="beaker">
                <div class="label-temp" id="disp-t1">20°C</div>
                <div class="water" id="water-1" style="height: 40%; background: #4d79ff;"></div>
            </div>
            <div class="beaker">
                <div class="label-temp" id="disp-t2">80°C</div>
                <div class="water" id="water-2" style="height: 40%; background: #ff4d4d;"></div>
            </div>
        </div>

        <div class="beaker" id="mix-beaker" style="display:none; width: 100px; height: 140px; margin-bottom:10px;">
            <div class="label-temp" id="disp-mix">--°C</div>
            <div class="water" id="water-mix" style="height: 0%; background: #a64dff; transition: height 1s, background 1s;"></div>
        </div>

    </div>

    <canvas id="simCanvas" class="view-layer"></canvas>
            </div>            

            <div class="info-container" id="math-board">
                <div style="color:#666; font-size:0.9rem; text-align:center;">
                    請輸入下方數據，<br>並按下「開始混合」觀察實驗。
                </div>
            </div>

        </main>

        <footer class="controls-dock">
            <div class="settings-panel">
                <div class="mode-switch-row">
                    <div class="mode-btn active" id="mode-liquid">液體混合</div>
                    <div class="mode-btn" id="mode-solid">固體投入</div>
                </div>

                <div class="params-grid">
    <div class="param-col">
        <div class="param-col-header cold" id="lbl-obj1">液體 (A)</div>
        
        <div class="param-row">
            <div class="param-item input-group">
                <label>質量(g)</label>
                <input type="number" id="m1" class="input-box" value="100">
            </div>
            <div class="param-item input-group">
                <label>初溫(°C)</label>
                <input type="number" id="t1" class="input-box" value="20">
            </div>
        </div>

        <div class="input-group inline">
            <label>比熱</label>
            <input type="number" id="s1" class="input-box" value="1">
        </div>
    </div>

    <div class="param-col">
        <div class="param-col-header hot" id="lbl-obj2">液體 (B)</div>
        
        <div class="param-row">
            <div class="param-item input-group">
                <label>質量(g)</label>
                <input type="number" id="m2" class="input-box" value="100">
            </div>
            <div class="param-item input-group">
                <label>初溫(°C)</label>
                <input type="number" id="t2" class="input-box" value="80">
            </div>
        </div>

        <div class="input-group inline">
            <label>比熱</label>
            <input type="number" id="s2" class="input-box" value="1">
        </div>
    </div>
</div>

                <div class="final-row">
                    <label style="font-weight:bold; color:#444;">平衡末溫 (°C)</label>
                    <input type="number" id="tmix" class="input-box" placeholder="?" style="width:100px; color:#d63031;">
                </div>
            </div>
			<button class="action-btn" id="btn-start" onclick="startSimulation()">開始混合</button>
            <button class="action-btn reset-btn" id="btn-reset" onclick="resetSimulation()" style="display:none;">重置實驗</button>
        </footer>

    </div>

    <script>
        // =========================================
        // 1. DOM 與 全域變數
        // =========================================
        const DOM = {
            // 液體模式專用
            initialGroup: document.getElementById('initial-group'),
            mixBeaker: document.getElementById('mix-beaker'),
            waterMix: document.getElementById('water-mix'),
            dispMix: document.getElementById('disp-mix'),
            
            // 【核心修復】這裡補上了 mathBoard 定義，且語法正確
            mathBoard: document.getElementById('math-board'),
            
            // 輸入欄位
            inputs: {
                m1: document.getElementById('m1'),
                t1: document.getElementById('t1'),
                s1: document.getElementById('s1'),
                m2: document.getElementById('m2'),
                t2: document.getElementById('t2'),
                s2: document.getElementById('s2'),
                tmix: document.getElementById('tmix')
            },
            
            // 介面控制
            btnModeLiquid: document.getElementById('mode-liquid'),
            btnModeSolid: document.getElementById('mode-solid'),
            lblObj1: document.getElementById('lbl-obj1'),
            lblObj2: document.getElementById('lbl-obj2'),
            btnStart: document.getElementById('btn-start'),
            btnReset: document.getElementById('btn-reset'),
            canvas: document.getElementById('simCanvas')
        };

        const ctx = DOM.canvas.getContext('2d');

        // 系統狀態
        let state = {
            mode: 'liquid',     
            phase: 'idle',      
            animationProgress: 0, 
            vals: { m1:100, t1:20, m2:100, t2:80, tmix:50 } 
        };

        // =========================================
        // 2. 初始化與事件綁定
        // =========================================
        function init() {
            // 防止 canvas 尚未載入導致報錯
            if(DOM.canvas) {
                resizeCanvas();
                window.addEventListener('resize', resizeCanvas);
            }

            // 綁定事件
            DOM.btnModeLiquid.addEventListener('click', () => setMode('liquid'));
            DOM.btnModeSolid.addEventListener('click', () => setMode('solid'));
            
            Object.values(DOM.inputs).forEach(inp => {
                if(inp) inp.addEventListener('input', updateStateFromInputs);
            });

            // 啟動迴圈
            requestAnimationFrame(renderLoop);

            // 初始設定
            setMode('liquid');
            updateStateFromInputs();
        }

        function resizeCanvas() {
            const rect = DOM.canvas.parentElement.getBoundingClientRect();
            DOM.canvas.width = rect.width * 2;
            DOM.canvas.height = rect.height * 2;
            ctx.scale(2, 2);
        }

        // =========================================
        // 3. 邏輯控制
        // =========================================
        function setMode(mode) {
            state.mode = mode;
            state.phase = 'idle';
            state.animationProgress = 0;

            const viewLiquid = document.getElementById('view-liquid');
            const viewCanvas = document.getElementById('simCanvas');

            if (mode === 'liquid') {
                viewLiquid.classList.add('active');
                viewCanvas.classList.remove('active');
                DOM.btnModeLiquid.classList.add('active');
                DOM.btnModeSolid.classList.remove('active');
                DOM.lblObj1.textContent = "液體 (A)";
                DOM.lblObj2.textContent = "液體 (B)";
                DOM.inputs.s1.value = 1;
                DOM.inputs.s2.value = 1;
            } else {
                viewLiquid.classList.remove('active');
                viewCanvas.classList.add('active');
                DOM.btnModeLiquid.classList.remove('active');
                DOM.btnModeSolid.classList.add('active');
                DOM.lblObj1.textContent = "液體";
                DOM.lblObj2.textContent = "投入物";
                DOM.inputs.s1.value = 1;
                DOM.inputs.s2.value = 0.09; 
            }
            updateStateFromInputs();
        }

        function updateStateFromInputs() {
            // 1. 完整讀取所有數值 (確保 m1 不會被漏掉)
            state.vals.m1 = parseFloat(DOM.inputs.m1.value) || 0;
            state.vals.t1 = parseFloat(DOM.inputs.t1.value) || 0;
            state.vals.m2 = parseFloat(DOM.inputs.m2.value) || 0;
            state.vals.t2 = parseFloat(DOM.inputs.t2.value) || 0;

            if (state.mode === 'liquid') {
                // 更新文字標籤
                document.getElementById('disp-t1').textContent = state.vals.t1 + "°C";
                document.getElementById('disp-t2').textContent = state.vals.t2 + "°C";
                
                // === 動態比例縮放邏輯 ===
                // 找出目前輸入的最大質量，以此為基準 (避免小數值看不見，大數值爆框)
                let maxM = Math.max(state.vals.m1, state.vals.m2);
                if(maxM <= 0) maxM = 1;

                // 設定顯示高度：最大杯設為 80% 高度，另一杯依比例顯示
                const h1 = (state.vals.m1 / maxM) * 80;
                const h2 = (state.vals.m2 / maxM) * 80;
                
                const w1 = document.getElementById('water-1');
                const w2 = document.getElementById('water-2');
                
                // 確保元素存在才修改
                if(w1) { 
                    w1.style.height = h1 + "%"; 
                    w1.style.background = tempToColor(state.vals.t1); 
                }
                if(w2) { 
                    w2.style.height = h2 + "%"; 
                    w2.style.background = tempToColor(state.vals.t2); 
                }
            }
        }

        // =========================================
        // 4. 核心解題引擎
        // =========================================
        async function startSimulation() {
            // 防呆
            if(state.phase !== 'idle' && state.phase !== 'result') return;

            // 1. 取得原始輸入
            const raw = {
                m1: DOM.inputs.m1.value,
                t1: DOM.inputs.t1.value,
                s1: DOM.inputs.s1.value,
                m2: DOM.inputs.m2.value,
                t2: DOM.inputs.t2.value,
                s2: DOM.inputs.s2.value,
                tmix: DOM.inputs.tmix.value
            };

            // 2. 轉為數值
            let v = {
                m1: parseFloat(raw.m1), t1: parseFloat(raw.t1), s1: parseFloat(raw.s1),
                m2: parseFloat(raw.m2), t2: parseFloat(raw.t2), s2: parseFloat(raw.s2),
                tmix: parseFloat(raw.tmix)
            };

            // 3. 判斷解題模式 (誰是空格?)
            // 找出所有數值為 NaN (即空格) 的欄位名稱
            const allKeys = ['m1', 't1', 's1', 'm2', 't2', 's2', 'tmix'];
            const empties = allKeys.filter(k => isNaN(v[k]));
            
            let target = '';

            if (empties.length > 1) {
                // 如果空格超過 1 個 (例如: 沒填末溫，也沒填質量) -> 報錯
                alert("資料不足，無法計算");
                return; // 直接結束，不跑動畫，不跑算式
            }
            else if (empties.length === 1) {
                // 只有 1 個空格 -> 它就是我們要算的目標
                target = empties[0];
            }
            else {
                // 0 個空格 (全部填滿) -> 視為驗證模式，預設重算末溫
                target = 'tmix';
            }

            // 4. 執行計算核心 (Solver)
            // 基礎公式: m1*s1*(T - t1) + m2*s2*(T - t2) = 0
            // 移項原理: 吸熱 = -放熱
            try {
                if (target === 'tmix') {
                    // 正向計算
                    v.tmix = (v.m1*v.s1*v.t1 + v.m2*v.s2*v.t2) / (v.m1*v.s1 + v.m2*v.s2);
                } 
                else if (target === 'm1') {
                    // m1 = - [m2*s2*(T - t2)] / [s1*(T - t1)]
                    let numer = -1 * v.m2 * v.s2 * (v.tmix - v.t2);
                    let denom = v.s1 * (v.tmix - v.t1);
                    if (Math.abs(denom) < 0.001) throw "溫差過小，無法計算質量";
                    v.m1 = numer / denom;
                }
                else if (target === 'm2') {
                    // m2 = - [m1*s1*(T - t1)] / [s2*(T - t2)]
                    let numer = -1 * v.m1 * v.s1 * (v.tmix - v.t1);
                    let denom = v.s2 * (v.tmix - v.t2);
                    if (Math.abs(denom) < 0.001) throw "溫差過小，無法計算質量";
                    v.m2 = numer / denom;
                }
                else if (target === 't1') {
                    // t1 = T + [m2*s2*(T - t2)] / (m1*s1)
                    let term = (v.m2 * v.s2 * (v.tmix - v.t2)) / (v.m1 * v.s1);
                    v.t1 = v.tmix + term;
                }
                else if (target === 't2') {
                    let term = (v.m1 * v.s1 * (v.tmix - v.t1)) / (v.m2 * v.s2);
                    v.t2 = v.tmix + term;
                }
                // === 【新增】比熱反求邏輯 ===
                else if (target === 's1') {
                    // s1 = - [m2*s2*(T - t2)] / [m1*(T - t1)]
                    let numer = -1 * v.m2 * v.s2 * (v.tmix - v.t2);
                    let denom = v.m1 * (v.tmix - v.t1);
                    if (Math.abs(denom) < 0.001) throw "溫差過小或質量為0，無法計算比熱";
                    v.s1 = numer / denom;
                }
                else if (target === 's2') {
                    // s2 = - [m1*s1*(T - t1)] / [m2*(T - t2)]
                    let numer = -1 * v.m1 * v.s1 * (v.tmix - v.t1);
                    let denom = v.m2 * (v.tmix - v.t2);
                    if (Math.abs(denom) < 0.001) throw "溫差過小或質量為0，無法計算比熱";
                    v.s2 = numer / denom;
                }
                // ==========================
                
                // 物理合理性檢查
                if (v.m1 < 0 || v.m2 < 0) throw "計算結果異常 (質量為負)";
                if (v.s1 <= 0 || v.s2 <= 0) throw "計算結果異常 (比熱非正值)，請檢查溫度設定是否違反熱力學方向。";
                
            } catch (err) {
                alert("計算錯誤：" + err);
                return;
            }

            // 5. 回填數值 (使用 parseFloat 去除整數後面的 .0)
            v.m1 = parseFloat(v.m1.toFixed(1));
            v.t1 = parseFloat(v.t1.toFixed(1));
            v.s1 = parseFloat(v.s1.toFixed(3)); // 比熱維持 3 位
            v.m2 = parseFloat(v.m2.toFixed(1));
            v.t2 = parseFloat(v.t2.toFixed(1));
            v.s2 = parseFloat(v.s2.toFixed(3)); // 比熱維持 3 位
            v.tmix = parseFloat(v.tmix.toFixed(1));

            // 更新輸入框
            DOM.inputs.m1.value = v.m1;
            DOM.inputs.t1.value = v.t1;
            DOM.inputs.s1.value = v.s1;
            DOM.inputs.m2.value = v.m2;
            DOM.inputs.t2.value = v.t2;
            DOM.inputs.s2.value = v.s2;
            DOM.inputs.tmix.value = v.tmix;

            // 更新全域狀態
            state.vals = JSON.parse(JSON.stringify(v));

            // 6. 介面鎖定
            lockInputs(true);
            DOM.btnStart.style.display = 'none';
            DOM.btnReset.style.display = 'block';
            
            // 呼叫算式繪製 (這邊顯示的算式文字可能需要通用化，目前先維持正向顯示，但數值是對的)
            renderMathSteps(v, target);

            // 7. 動畫啟動
            if (state.mode === 'liquid') {
                DOM.initialGroup.style.display = 'none';
                DOM.mixBeaker.style.display = 'flex';
                DOM.dispMix.textContent = v.tmix.toFixed(1) + "°C";
                DOM.waterMix.style.background = tempToColor(v.tmix);
                DOM.waterMix.style.height = '0%';

                setTimeout(() => {
                    let hPercent = 80; 
                    DOM.waterMix.style.height = hPercent + "%";
                }, 50);

            } else {
                state.phase = 'animating';
                let startTime = null;
                function animate(timestamp) {
                    if (!startTime) startTime = timestamp;
                    let progress = (timestamp - startTime) / 2000;
                    if (progress > 1) progress = 1;
                    state.animationProgress = progress;
                    if (progress < 1) requestAnimationFrame(animate);
                    else state.phase = 'result';
                }
                requestAnimationFrame(animate);
            }
        }

        function resetSimulation() {
            lockInputs(false);
            DOM.inputs.tmix.value = '';
            DOM.btnStart.style.display = 'block';
            DOM.btnReset.style.display = 'none';
            state.phase = 'idle';
            state.animationProgress = 0;
            
            if(DOM.initialGroup) {
                DOM.initialGroup.style.display = 'flex';
                DOM.mixBeaker.style.display = 'none';
                if(DOM.waterMix) DOM.waterMix.style.height = '0%';
            }
            updateStateFromInputs();
            
            // 清空算式區
            if(DOM.mathBoard) DOM.mathBoard.innerHTML = '<div style="color:#666; font-size:0.9rem; text-align:center;">請輸入下方數據，<br>並按下「開始混合」觀察實驗。</div>';
        }
        
        function lockInputs(lock) {
            Object.values(DOM.inputs).forEach(inp => {
                if(inp && inp.id !== 'tmix') inp.disabled = lock;
            });
        }

        // =========================================
        // 5. 視覺渲染引擎 (Canvas)
        // =========================================
        function renderLoop() {
            if(!ctx) return;
            const w = DOM.canvas.width / 2;
            const h = DOM.canvas.height / 2;
            ctx.clearRect(0, 0, w, h);

            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            if (state.mode === 'liquid') {
                drawLiquidMode(w, h);
            } else {
                drawSolidMode(w, h);
            }

            requestAnimationFrame(renderLoop);
        }

        function drawLiquidMode(w, h) {
            const floorY = h - 20;
            const cupW = 60;
            const cupH = 100;
            const gap = 40;
            const p = state.animationProgress;
            
            if (p < 0.8) {
                const x1 = w/2 - cupW - gap/2;
                const h1 = Math.min(state.vals.m1 * 0.8, cupH - 10);
                const color1 = tempToColor(state.vals.t1);
                drawBeaker(x1, floorY, cupW, cupH, h1, color1, "低溫");
            }

            if (p < 0.5) {
                const x2 = w/2 + gap/2;
                const h2 = Math.min(state.vals.m2 * 0.8, cupH - 10);
                const color2 = tempToColor(state.vals.t2);
                const moveX = x2 - p * (gap + cupW); 
                drawBeaker(moveX, floorY, cupW, cupH, h2, color2, "高溫");
            }

            if (p > 0.3) {
                const mixP = (p - 0.3) / 0.7;
                const xMix = w/2 - cupW/2;
                const finalMass = state.vals.m1 + state.vals.m2;
                const hMix = Math.min(finalMass * 0.8, cupH - 5) * mixP;
                const currentTemp = state.vals.tmix;
                const colorMix = tempToColor(currentTemp);

                drawBeaker(xMix, floorY, cupW, cupH, hMix, colorMix, p > 0.9 ? "混合後" : "");
            }
        }

        function drawSolidMode(w, h) {
            const floorY = h - 20;
            const cupW = 80;
            const cupH = 120;
            const centerX = w / 2 - cupW / 2;

            // 1. 計算基礎水位 (原本的水量)
            let baseH = Math.min(state.vals.m1 * 0.6, cupH - 30);
            
            // 2. 計算水位上升量 (Displacement)
            // 當動畫進度 > 0.5 (金屬塊接觸水面) 時，水位開始上升
            // 假設最大上升 15px
            let riseH = 0;
            if (state.animationProgress > 0.7) {
                // 正規化進度：0.5 ~ 1.0 轉換為 0 ~ 1
                const enterProgress = (state.animationProgress - 0.5) * 2;
                riseH = enterProgress * 15;
            }
            // 若已是結果狀態，保持最高水位
            if (state.phase === 'result') riseH = 15;

            const finalH = baseH + riseH;
            
            // 3. 繪製水 (使用動態計算的高度)
            const waterColor = state.phase === 'result' ? tempToColor(state.vals.tmix) : tempToColor(state.vals.t1);
            drawBeaker(centerX, floorY, cupW, cupH, finalH, waterColor, "液體");

            // 4. 繪製金屬塊動畫
            const startY = 50;
            // 目標位置：底部減去一點點 (沉底)
            const endY = floorY - 10; 
            const currentY = startY + (endY - startY) * state.animationProgress;
            
            const blockSize = 30;
            const blockColor = tempToColor(state.vals.t2);
            
            ctx.fillStyle = blockColor;
            ctx.strokeStyle = '#555';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.rect(w/2 - blockSize/2, currentY - blockSize, blockSize, blockSize);
            ctx.fill();
            ctx.stroke();
            
            // 標籤
            ctx.fillStyle = '#333';
            ctx.font = 'bold 12px Arial';
            ctx.fillText("固體", w/2 - 12, currentY - blockSize - 5);
        }

        function drawBeaker(x, y, w, h, waterH, color, label) {
            const r = 10; // 設定燒杯底部的圓角半徑
            
            // 1. 定義燒杯的路徑 (U型)
            // 我們把路徑存起來，等一下「畫線」和「裁切液體」都要用同一條，保證密合
            ctx.beginPath();
            ctx.moveTo(x, y - h);           // 左上
            ctx.lineTo(x, y - r);           // 左下 (準備轉彎)
            ctx.quadraticCurveTo(x, y, x + r, y); // 左下圓角
            ctx.lineTo(x + w - r, y);       // 底部直線
            ctx.quadraticCurveTo(x + w, y, x + w, y - r); // 右下圓角
            ctx.lineTo(x + w, y - h);       // 右上

            // 2. 繪製液體 (使用 Clip 裁切)
            if (waterH > 0) {
                ctx.save(); // 暫存畫布狀態
                
                // 設為裁切區域 (之後畫的東西只能出現在剛剛的路徑內)
                ctx.clip(); 
                
                ctx.fillStyle = color;
                // 直接畫一個矩形，Clip 會自動幫我們把超出的角落切掉
                // y - waterH 是液面高度，多加一點高度(h)確保底部填滿
                ctx.fillRect(x, y - waterH, w, h); 
                
                ctx.restore(); // 恢復畫布，取消裁切限制，以免影響邊框
            }

            // 3. 繪製燒杯邊框 (蓋在液體上面)
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 3;
            ctx.stroke();

            // 4. 文字標籤
            if (label) {
                ctx.fillStyle = '#333';
                ctx.font = 'bold 12px Arial';
                ctx.fillText(label, x + w/2 - 10, y + 18);
            }
        }

        function tempToColor(t) {
            const ratio = Math.max(0, Math.min(1, t / 100));
            const r = Math.round(52 + (231 - 52) * ratio);
            const g = Math.round(152 + (76 - 152) * ratio);
            const b = Math.round(219 + (60 - 219) * ratio);
            return `rgb(${r}, ${g}, ${b})`;
        }

        // =========================================
        // 6. 智慧算式推導引擎 (整數優化版)
        // =========================================
        async function renderMathSteps(v, target) {
            const board = document.getElementById('math-board'); 
            if (!board) return;

            board.innerHTML = ''; 

            // 工具：加入一行算式
            const addLine = async (html, delay) => {
                const div = document.createElement('div');
                div.style.cssText = "margin: 5px 0; padding: 6px 8px; border-left: 4px solid #3498db; background: rgba(255,255,255,0.95); opacity: 0; transform: translateX(-10px); transition: all 0.5s ease; font-size: 0.95rem; line-height: 1.4; border-radius: 0 6px 6px 0; box-shadow: 0 1px 3px rgba(0,0,0,0.05);";
                div.innerHTML = html;
                board.appendChild(div);
                void div.offsetWidth; 
                div.style.opacity = '1';
                div.style.transform = 'translateX(0)';
                await new Promise(r => setTimeout(r, delay));
            };

            // --- 樣式與格式化工具 ---
            const red = (txt) => `<span style="color:#d63031; font-weight:bold; font-size:1.1em;">${txt}</span>`;
            const blue = (txt) => `<span style="color:#0984e3; font-weight:bold;">${txt}</span>`;
            const num = (n) => `<span style="font-family:Consolas, monospace; color:#2d3436;">${n}</span>`;
            const unit = (u) => `<span style="color:#888; font-size:0.85em; margin-left:2px;">${u}</span>`;
            
            // 【核心修改】智慧格式化：先取小數點，再轉浮點數以去除無用的 .0
            // 如果是整數 40.0 -> 變成 40
            // 如果是小數 40.5 -> 保持 40.5
            const fmt = (n, d=1) => parseFloat(n.toFixed(d));

            const headerStyle = "font-weight:bold; margin-bottom:2px; border-bottom:1px solid #eee; padding-bottom:2px; font-size:0.9rem; color:#555;";

            // --- Step 1: 物理原理 ---
            await addLine(`
                <div style="${headerStyle}">Step 1: 熱平衡原理</div>
                ${blue("低溫吸熱")} ＝ ${red("高溫放熱")}
            `, 800);

            // --- Step 2: 列出方程式 ---
            const show = (key) => (key === target) ? red(key) : num(fmt(v[key], key.startsWith('s') ? 3 : 1));

            // 處理 T 的顯示 (只有算末溫時顯示符號，反求時顯示數值)
            const T_display = (target === 'tmix') ? red("T") : num(fmt(v.tmix));

            // 組合溫差字串
            let dt1_str = `(${T_display} - ${show('t1')})`;
            let dt2_str = `(${show('t2')} - ${T_display})`;

            const leftExp = `${show('m1')}×${show('s1')}×${dt1_str}`;
            const rightExp = `${show('m2')}×${show('s2')}×${dt2_str}`;

            await addLine(`
                <div style="${headerStyle}">Step 2: 代入數值</div>
                ${leftExp} ＝ ${rightExp}
            `, 1000);

            // --- Step 3: 直接顯示答案 ---
            let resultHTML = '';
            let val = v[target]; // 已經在 startSimulation 轉成漂亮數字了，這裡直接用即可
            
            if (target === 'tmix') {
                resultHTML = `解得平衡溫度 ${red("T")} ≈ ${red(val)} ${unit("°C")}`;
            } 
            else if (['m1', 'm2'].includes(target)) {
                resultHTML = `解得質量 ${red(target)} ≈ ${red(val)} ${unit("g")}`;
            }
            else if (['s1', 's2'].includes(target)) {
                resultHTML = `解得比熱 ${red(target)} ≈ ${red(val)} ${unit("cal/g·°C")}`;
            }
            else if (['t1', 't2'].includes(target)) {
                resultHTML = `反推初始溫度 ${red(target)} ≈ ${red(val)} ${unit("°C")}`;
            }

            await addLine(`
                <div style="${headerStyle}">Step 3: 計算結果</div>
                ${resultHTML}
            `, 0);
        }

        window.addEventListener('load', init);

    </script>
</body>
</html>